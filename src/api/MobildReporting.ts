//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase, HttpContext } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class StoreConnectionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://jr8qjxj4-44373.asse.devtunnels.ms";
    }

    getDeliProducts(storeAccessKey: string | null | undefined, httpContext?: HttpContext): Observable<FileResponse> {
        let url_ = this.baseUrl + "/StoreConnection/DeliProducts?";
        if (storeAccessKey !== undefined && storeAccessKey !== null)
            url_ += "StoreAccessKey=" + encodeURIComponent("" + storeAccessKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeliProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeliProducts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetDeliProducts(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductsCorrelationCoefficient(storeAccessKey: string | null | undefined, pluUpcs: string[] | null | undefined, httpContext?: HttpContext): Observable<FileResponse> {
        let url_ = this.baseUrl + "/StoreConnection/ProductsCorrelationCoefficient?";
        if (storeAccessKey !== undefined && storeAccessKey !== null)
            url_ += "StoreAccessKey=" + encodeURIComponent("" + storeAccessKey) + "&";
        if (pluUpcs !== undefined && pluUpcs !== null)
            pluUpcs && pluUpcs.forEach(item => { url_ += "PluUpcs=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductsCorrelationCoefficient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductsCorrelationCoefficient(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetProductsCorrelationCoefficient(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProducts(storeAccessKey: string | null | undefined, departments: string | null | undefined, excludedDepartments: boolean | undefined, pluUpcs: string[] | null | undefined, httpContext?: HttpContext): Observable<FileResponse> {
        let url_ = this.baseUrl + "/StoreConnection/Products?";
        if (storeAccessKey !== undefined && storeAccessKey !== null)
            url_ += "StoreAccessKey=" + encodeURIComponent("" + storeAccessKey) + "&";
        if (departments !== undefined && departments !== null)
            url_ += "Departments=" + encodeURIComponent("" + departments) + "&";
        if (excludedDepartments === null)
            throw new Error("The parameter 'excludedDepartments' cannot be null.");
        else if (excludedDepartments !== undefined)
            url_ += "ExcludedDepartments=" + encodeURIComponent("" + excludedDepartments) + "&";
        if (pluUpcs !== undefined && pluUpcs !== null)
            pluUpcs && pluUpcs.forEach(item => { url_ += "PluUpcs=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProducts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetProducts(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPromotions(storeAccessKey: string | null | undefined, pluUpcs: string[] | null | undefined, httpContext?: HttpContext): Observable<FileResponse> {
        let url_ = this.baseUrl + "/StoreConnection/Promotions?";
        if (storeAccessKey !== undefined && storeAccessKey !== null)
            url_ += "StoreAccessKey=" + encodeURIComponent("" + storeAccessKey) + "&";
        if (pluUpcs !== undefined && pluUpcs !== null)
            pluUpcs && pluUpcs.forEach(item => { url_ += "PluUpcs=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPromotions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPromotions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetPromotions(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getDiscounts(storeAccessKeys: string[] | null | undefined, startdate: Date | undefined, enddate: Date | undefined, httpContext?: HttpContext): Observable<Discount[]> {
        let url_ = this.baseUrl + "/StoreConnection/DiscountCoupons?";
        if (storeAccessKeys !== undefined && storeAccessKeys !== null)
            storeAccessKeys && storeAccessKeys.forEach(item => { url_ += "StoreAccessKeys=" + encodeURIComponent("" + item) + "&"; });
        if (startdate === null)
            throw new Error("The parameter 'startdate' cannot be null.");
        else if (startdate !== undefined)
            url_ += "Startdate=" + encodeURIComponent(startdate ? "" + startdate.toISOString() : "") + "&";
        if (enddate === null)
            throw new Error("The parameter 'enddate' cannot be null.");
        else if (enddate !== undefined)
            url_ += "Enddate=" + encodeURIComponent(enddate ? "" + enddate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDiscounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDiscounts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Discount[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Discount[]>;
        }));
    }

    protected processGetDiscounts(response: HttpResponseBase): Observable<Discount[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Discount.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(httpContext?: HttpContext): Observable<StoreConnection[]> {
        let url_ = this.baseUrl + "/StoreConnection";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreConnection[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreConnection[]>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<StoreConnection[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StoreConnection.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postTransactions(storeAccessKey: string | null | undefined, orderId: string | null | undefined, source: string | null | undefined, httpContext?: HttpContext): Observable<FileResponse> {
        let url_ = this.baseUrl + "/StoreConnection/Transactions?";
        if (storeAccessKey !== undefined && storeAccessKey !== null)
            url_ += "storeAccessKey=" + encodeURIComponent("" + storeAccessKey) + "&";
        if (orderId !== undefined && orderId !== null)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        if (source !== undefined && source !== null)
            url_ += "source=" + encodeURIComponent("" + source) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostTransactions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostTransactions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processPostTransactions(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postOrderRecive(storeAccessKey: string | null | undefined, orderId: string | null | undefined, source: string | null | undefined, httpContext?: HttpContext): Observable<FileResponse> {
        let url_ = this.baseUrl + "/StoreConnection/OrderRecive?";
        if (storeAccessKey !== undefined && storeAccessKey !== null)
            url_ += "storeAccessKey=" + encodeURIComponent("" + storeAccessKey) + "&";
        if (orderId !== undefined && orderId !== null)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        if (source !== undefined && source !== null)
            url_ += "source=" + encodeURIComponent("" + source) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostOrderRecive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostOrderRecive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processPostOrderRecive(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class BaseDataClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://jr8qjxj4-44373.asse.devtunnels.ms";
    }

    getDeaprtmrnts(stores: number[] | null | undefined, httpContext?: HttpContext): Observable<Department[]> {
        let url_ = this.baseUrl + "/api/BaseData/department?";
        if (stores !== undefined && stores !== null)
            stores && stores.forEach(item => { url_ += "stores=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeaprtmrnts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeaprtmrnts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Department[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Department[]>;
        }));
    }

    protected processGetDeaprtmrnts(response: HttpResponseBase): Observable<Department[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Department.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getVendors(stores: number[] | null | undefined, httpContext?: HttpContext): Observable<Vendor[]> {
        let url_ = this.baseUrl + "/api/BaseData/vendors?";
        if (stores !== undefined && stores !== null)
            stores && stores.forEach(item => { url_ += "stores=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVendors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVendors(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Vendor[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Vendor[]>;
        }));
    }

    protected processGetVendors(response: HttpResponseBase): Observable<Vendor[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Vendor.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getBrands(stores: number[] | null | undefined, httpContext?: HttpContext): Observable<Brand[]> {
        let url_ = this.baseUrl + "/api/BaseData/brands?";
        if (stores !== undefined && stores !== null)
            stores && stores.forEach(item => { url_ += "stores=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrands(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrands(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Brand[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Brand[]>;
        }));
    }

    protected processGetBrands(response: HttpResponseBase): Observable<Brand[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Brand.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTaxs(stores: number[] | null | undefined, httpContext?: HttpContext): Observable<TaxDto[]> {
        let url_ = this.baseUrl + "/api/BaseData/taxs?";
        if (stores !== undefined && stores !== null)
            stores && stores.forEach(item => { url_ += "stores=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTaxs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTaxs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TaxDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TaxDto[]>;
        }));
    }

    protected processGetTaxs(response: HttpResponseBase): Observable<TaxDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TaxDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getDepartmentGroup(stores: number[] | null | undefined, httpContext?: HttpContext): Observable<DepartmentGroupDto[]> {
        let url_ = this.baseUrl + "/api/BaseData/department/group?";
        if (stores !== undefined && stores !== null)
            stores && stores.forEach(item => { url_ += "stores=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepartmentGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepartmentGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DepartmentGroupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DepartmentGroupDto[]>;
        }));
    }

    protected processGetDepartmentGroup(response: HttpResponseBase): Observable<DepartmentGroupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DepartmentGroupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class BundlesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://jr8qjxj4-44373.asse.devtunnels.ms";
    }

    /**
     * 查询店铺下时间段的Bundles
     * @param storeId 店铺ID
     * @param endTime 结束时间
     */
    getBundles(storeId: number, endTime: Date, httpContext?: HttpContext): Observable<BundlesDto[]> {
        let url_ = this.baseUrl + "/api/Bundles/{storeId}/{endTime}";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (endTime === undefined || endTime === null)
            throw new Error("The parameter 'endTime' must be defined.");
        url_ = url_.replace("{endTime}", encodeURIComponent(endTime ? "" + endTime.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBundles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBundles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BundlesDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BundlesDto[]>;
        }));
    }

    protected processGetBundles(response: HttpResponseBase): Observable<BundlesDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BundlesDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    copyBundle(sourceStoreId: number, destinationStoreId: number, sourceBundleId: string, httpContext?: HttpContext): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Bundles/CopyBundle/{sourceStoreId}/{destinationStoreId}/{sourceBundleId}";
        if (sourceStoreId === undefined || sourceStoreId === null)
            throw new Error("The parameter 'sourceStoreId' must be defined.");
        url_ = url_.replace("{sourceStoreId}", encodeURIComponent("" + sourceStoreId));
        if (destinationStoreId === undefined || destinationStoreId === null)
            throw new Error("The parameter 'destinationStoreId' must be defined.");
        url_ = url_.replace("{destinationStoreId}", encodeURIComponent("" + destinationStoreId));
        if (sourceBundleId === undefined || sourceBundleId === null)
            throw new Error("The parameter 'sourceBundleId' must be defined.");
        url_ = url_.replace("{sourceBundleId}", encodeURIComponent("" + sourceBundleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCopyBundle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCopyBundle(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processCopyBundle(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CategroyClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://jr8qjxj4-44373.asse.devtunnels.ms";
    }

    /**
     * 修改category的scale
     * @param storeId (optional) 
     * @param categoryId (optional) 
     * @param isScale (optional) 
     */
    updateCategoryScale(storeId: number | undefined, categoryId: string | null | undefined, isScale: boolean | undefined, httpContext?: HttpContext): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Categroy/update/catrgory/scale?";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        if (categoryId !== undefined && categoryId !== null)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&";
        if (isScale === null)
            throw new Error("The parameter 'isScale' cannot be null.");
        else if (isScale !== undefined)
            url_ += "isScale=" + encodeURIComponent("" + isScale) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCategoryScale(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCategoryScale(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdateCategoryScale(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CompaniesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://jr8qjxj4-44373.asse.devtunnels.ms";
    }

    /**
     * 创建新的公司
     * @param companyName (optional) Company Name
     * @return Created Success!
     */
    createdCompany(companyName: string | null | undefined, httpContext?: HttpContext): Observable<CompanyDTO> {
        let url_ = this.baseUrl + "/api/Companies?";
        if (companyName !== undefined && companyName !== null)
            url_ += "companyName=" + encodeURIComponent("" + companyName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatedCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatedCompany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyDTO>;
        }));
    }

    protected processCreatedCompany(response: HttpResponseBase): Observable<CompanyDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("\u5f53\u524d\u521b\u5efa\u7684\u516c\u53f8\u540d\u5df2\u7ecf\u5b58\u5728\u6216\u8005\u521b\u5efa\u5931\u8d25", status, _responseText, _headers, result409);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 删除公司
     * @param id (optional) Company Id
     * @return Delete Success!
     */
    deleteCompany(id: number | undefined, httpContext?: HttpContext): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Companies?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCompany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteCompany(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return _observableOf(result204);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Not Found!", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Delete Faliure!", status, _responseText, _headers, result409);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 更新公司名字
     * @param id (optional) Conpany Id
     * @param companyName (optional) new Compant Name
     * @return Update Success!
     */
    updateCompay(id: number | undefined, companyName: string | null | undefined, httpContext?: HttpContext): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Companies?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (companyName !== undefined && companyName !== null)
            url_ += "companyName=" + encodeURIComponent("" + companyName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCompay(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCompay(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdateCompay(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return _observableOf(result204);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Not Found!", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("\u65b0\u7684\u516c\u53f8\u540d\u548c\u65e7\u7684\u516c\u53f8\u540d\u91cd\u590d\u6216\u8005\u6570\u636e\u5e93\u9519\u8bef", status, _responseText, _headers, result409);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 获取所有已存在的公司
     * @return Companies
     */
    getCompanies(httpContext?: HttpContext): Observable<CompaniesDTO> {
        let url_ = this.baseUrl + "/api/Companies";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompanies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompanies(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompaniesDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompaniesDTO>;
        }));
    }

    protected processGetCompanies(response: HttpResponseBase): Observable<CompaniesDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompaniesDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Not Found!", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DevicesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://jr8qjxj4-44373.asse.devtunnels.ms";
    }

    get(id: string | null, httpContext?: HttpContext): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Devices/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    put(id: string | null, body: Device, httpContext?: HttpContext): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Devices/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processPut(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postRecord(id: string | null, body: DeviceRecord, httpContext?: HttpContext): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Devices/{id}/records";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostRecord(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processPostRecord(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class InvoivesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://jr8qjxj4-44373.asse.devtunnels.ms";
    }

    uploadDataWithFile(storeId: number | undefined, supplierType: SupplierType | undefined, contentType: string | null | undefined, contentDisposition: string | null | undefined, headers: IHeaderDictionary | null | undefined, length: number | undefined, name: string | null | undefined, fileName: string | null | undefined, productDocuments: FileParameter[] | null | undefined, httpContext?: HttpContext): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Invoives/Upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (storeId === null || storeId === undefined)
            throw new Error("The parameter 'storeId' cannot be null.");
        else
            content_.append("storeId", storeId.toString());
        if (supplierType === null || supplierType === undefined)
            throw new Error("The parameter 'supplierType' cannot be null.");
        else
            content_.append("supplierType", supplierType.toString());
        if (contentType !== null && contentType !== undefined)
            content_.append("ContentType", contentType.toString());
        if (contentDisposition !== null && contentDisposition !== undefined)
            content_.append("ContentDisposition", contentDisposition.toString());
        if (headers !== null && headers !== undefined)
            content_.append("Headers", JSON.stringify(headers));
        if (length === null || length === undefined)
            throw new Error("The parameter 'length' cannot be null.");
        else
            content_.append("Length", length.toString());
        if (name !== null && name !== undefined)
            content_.append("Name", name.toString());
        if (fileName !== null && fileName !== undefined)
            content_.append("FileName", fileName.toString());
        if (productDocuments !== null && productDocuments !== undefined)
            productDocuments.forEach(item_ => content_.append("ProductDocuments", item_.data, item_.fileName ? item_.fileName : "ProductDocuments") );

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadDataWithFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadDataWithFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUploadDataWithFile(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class LogClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://jr8qjxj4-44373.asse.devtunnels.ms";
    }

    downLoadLog(httpContext?: HttpContext): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Log";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownLoadLog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownLoadLog(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDownLoadLog(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    clearLog(httpContext?: HttpContext): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Log";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearLog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearLog(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processClearLog(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class MixcodeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://jr8qjxj4-44373.asse.devtunnels.ms";
    }

    /**
     * 转移当前店铺的Mixcode数据到目标店铺
     */
    transferMixcode(body: TransferMixcodeBodyDto, httpContext?: HttpContext): Observable<FileResponse> {
        let url_ = this.baseUrl + "/transfer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTransferMixcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransferMixcode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processTransferMixcode(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 获取当前店铺下的所有Mixcode
     * @param currentStore (optional) 当前店铺
     */
    mixcodes(currentStore: number | undefined, httpContext?: HttpContext): Observable<string[]> {
        let url_ = this.baseUrl + "/api/Mixcode?";
        if (currentStore === null)
            throw new Error("The parameter 'currentStore' cannot be null.");
        else if (currentStore !== undefined)
            url_ += "currentStore=" + encodeURIComponent("" + currentStore) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMixcodes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMixcodes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processMixcodes(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class NationsbenefitsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://jr8qjxj4-44373.asse.devtunnels.ms";
    }

    accountValidation(body: AVSRequest, httpContext?: HttpContext): Observable<AVSResponse> {
        let url_ = this.baseUrl + "/nationsbenefits/accountValidation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountValidation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountValidation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AVSResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AVSResponse>;
        }));
    }

    protected processAccountValidation(response: HttpResponseBase): Observable<AVSResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AVSResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    balanceInquiry(body: BIRequest, httpContext?: HttpContext): Observable<BIResponse> {
        let url_ = this.baseUrl + "/nationsbenefits/balanceInquiry";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBalanceInquiry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBalanceInquiry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BIResponse>;
        }));
    }

    protected processBalanceInquiry(response: HttpResponseBase): Observable<BIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    analyze(body: AnalyzeRequest, httpContext?: HttpContext): Observable<AnalyzeResponse> {
        let url_ = this.baseUrl + "/nationsbenefits/analyze";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAnalyze(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAnalyze(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AnalyzeResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AnalyzeResponse>;
        }));
    }

    protected processAnalyze(response: HttpResponseBase): Observable<AnalyzeResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AnalyzeResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    redeem(body: RedeemRequest, httpContext?: HttpContext): Observable<RedeemResponse> {
        let url_ = this.baseUrl + "/nationsbenefits/redeem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRedeem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRedeem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RedeemResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RedeemResponse>;
        }));
    }

    protected processRedeem(response: HttpResponseBase): Observable<RedeemResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RedeemResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    void(body: VoidRequest, httpContext?: HttpContext): Observable<VoidResponse> {
        let url_ = this.baseUrl + "/nationsbenefits/void";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVoid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVoid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VoidResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VoidResponse>;
        }));
    }

    protected processVoid(response: HttpResponseBase): Observable<VoidResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VoidResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    reversal(body: ReversalRequest, httpContext?: HttpContext): Observable<ReversalResponse> {
        let url_ = this.baseUrl + "/nationsbenefits/reversal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReversal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReversal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReversalResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReversalResponse>;
        }));
    }

    protected processReversal(response: HttpResponseBase): Observable<ReversalResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReversalResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class NegativePriceProductMovementReportClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://jr8qjxj4-44373.asse.devtunnels.ms";
    }

    getNegativePriceProductMovement(stores: number[] | null | undefined, begin: string | null | undefined, end: string | null | undefined, httpContext?: HttpContext): Observable<NegativePriceProductMovementDto[]> {
        let url_ = this.baseUrl + "/api/NegativePriceProductMovementReport?";
        if (stores !== undefined && stores !== null)
            stores && stores.forEach(item => { url_ += "stores=" + encodeURIComponent("" + item) + "&"; });
        if (begin !== undefined && begin !== null)
            url_ += "begin=" + encodeURIComponent("" + begin) + "&";
        if (end !== undefined && end !== null)
            url_ += "end=" + encodeURIComponent("" + end) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNegativePriceProductMovement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNegativePriceProductMovement(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NegativePriceProductMovementDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NegativePriceProductMovementDto[]>;
        }));
    }

    protected processGetNegativePriceProductMovement(response: HttpResponseBase): Observable<NegativePriceProductMovementDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NegativePriceProductMovementDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class PayMentClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://jr8qjxj4-44373.asse.devtunnels.ms";
    }

    /**
     * 获取支付信息
     * @param storeId 店铺id
     * @param paymentId 支付Id
     * @return Success!
     */
    getPayMentContent(storeId: number, paymentId: string | null, httpContext?: HttpContext): Observable<TransactionResponse> {
        let url_ = this.baseUrl + "/approval/transaction/{storeId}/{paymentId}";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (paymentId === undefined || paymentId === null)
            throw new Error("The parameter 'paymentId' must be defined.");
        url_ = url_.replace("{paymentId}", encodeURIComponent("" + paymentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayMentContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayMentContent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransactionResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransactionResponse>;
        }));
    }

    protected processGetPayMentContent(response: HttpResponseBase): Observable<TransactionResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Not Found!", status, _responseText, _headers, result404);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransactionResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 验证信用卡用户支付
     * @param storeId (optional) 店铺id
     * @param paymentId (optional) 支付id
     * @param userPayment 用户支付信息
     * @return Success!
     */
    putUserPayMent(storeId: number | undefined, paymentId: string | null | undefined, userPayment: UserPayment, httpContext?: HttpContext): Observable<FileResponse> {
        let url_ = this.baseUrl + "/approval/modify/userPayMent?";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        if (paymentId !== undefined && paymentId !== null)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userPayment);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPutUserPayMent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutUserPayMent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processPutUserPayMent(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ValidationProblemDetails.fromJS(resultData404);
            return throwException("Not Found!", status, _responseText, _headers, result404);
            }));
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result504: any = null;
            let resultData504 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result504 = ValidationProblemDetails.fromJS(resultData504);
            return throwException("Time Out!", status, _responseText, _headers, result504);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Payment Failure!", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 修改状态
     * @param storeId (optional) 店铺id
     * @param paymentId (optional) 支付id
     * @param statusText (optional) 状态文本
     * @return Success!
     */
    putPayMentStatus(storeId: number | undefined, paymentId: string | null | undefined, statusText: string | null | undefined, httpContext?: HttpContext): Observable<FileResponse> {
        let url_ = this.baseUrl + "/approval/modify/status?";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        if (paymentId !== undefined && paymentId !== null)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        if (statusText !== undefined && statusText !== null)
            url_ += "statusText=" + encodeURIComponent("" + statusText) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPutPayMentStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutPayMentStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processPutPayMentStatus(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Not Found!", status, _responseText, _headers, result404);
            }));
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class PosuserLogIntTokenClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://jr8qjxj4-44373.asse.devtunnels.ms";
    }

    /**
     * 获取Token 重定向
     * @param storeId 商店id
     * @param registerNumber 收银台id
     * @param devmode (optional) true:开发者模式 false: 生产模式
     */
    getLoginToken(storeId: string | null, registerNumber: string | null, devmode: boolean | undefined, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/posuserlogintoken/{storeId}/{registerNumber}?";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (registerNumber === undefined || registerNumber === null)
            throw new Error("The parameter 'registerNumber' must be defined.");
        url_ = url_.replace("{registerNumber}", encodeURIComponent("" + registerNumber));
        if (devmode === null)
            throw new Error("The parameter 'devmode' cannot be null.");
        else if (devmode !== undefined)
            url_ += "devmode=" + encodeURIComponent("" + devmode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoginToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoginToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetLoginToken(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 302) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result302: any = null;
            let resultData302 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result302 = resultData302 !== undefined ? resultData302 : <any>null;
    
            return throwException("\u91cd\u5b9a\u5411", status, _responseText, _headers, result302);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Not Found!", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 登录
     * @param userLoginToken Token
     * @param lanenumber 手机号
     * @return 请求成功
     */
    userLogin(userLoginToken: string | null, lanenumber: string | null, httpContext?: HttpContext): Observable<CustomerResponse> {
        let url_ = this.baseUrl + "/userLogin/{userLoginToken}/{lanenumber}";
        if (userLoginToken === undefined || userLoginToken === null)
            throw new Error("The parameter 'userLoginToken' must be defined.");
        url_ = url_.replace("{userLoginToken}", encodeURIComponent("" + userLoginToken));
        if (lanenumber === undefined || lanenumber === null)
            throw new Error("The parameter 'lanenumber' must be defined.");
        url_ = url_.replace("{lanenumber}", encodeURIComponent("" + lanenumber));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerResponse>;
        }));
    }

    protected processUserLogin(response: HttpResponseBase): Observable<CustomerResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Not Found!", status, _responseText, _headers, result404);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ValidationProblemDetails.fromJS(resultData406);
            return throwException("\u53c2\u6570\u9519\u8bef", status, _responseText, _headers, result406);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ValidationProblemDetails.fromJS(resultData401);
            return throwException("Token \u8fc7\u671f", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 注册
     * @param registerToken 注册Token
     * @param customerItem 新用户数据
     * @return 请求成功
     */
    userRegister(registerToken: string | null, customerItem: RegisterRequest, httpContext?: HttpContext): Observable<CustomerResponse> {
        let url_ = this.baseUrl + "/userRegisterTask/{registerToken}";
        if (registerToken === undefined || registerToken === null)
            throw new Error("The parameter 'registerToken' must be defined.");
        url_ = url_.replace("{registerToken}", encodeURIComponent("" + registerToken));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(customerItem);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerResponse>;
        }));
    }

    protected processUserRegister(response: HttpResponseBase): Observable<CustomerResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ValidationProblemDetails.fromJS(resultData406);
            return throwException("\u53c2\u6570\u9519\u8bef", status, _responseText, _headers, result406);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Not Fond", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ValidationProblemDetails.fromJS(resultData401);
            return throwException("Token \u8fc7\u671f", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 修改用户数据
     * @param storeId 店铺id
     * @param phoneNumber 用户账户
     * @param custom 用户数据
     * @return 更新成功
     */
    userUpdate(storeId: number, phoneNumber: string | null, custom: CustomUpdateRequest, httpContext?: HttpContext): Observable<FileResponse> {
        let url_ = this.baseUrl + "/{storeId}/{phoneNumber}";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (phoneNumber === undefined || phoneNumber === null)
            throw new Error("The parameter 'phoneNumber' must be defined.");
        url_ = url_.replace("{phoneNumber}", encodeURIComponent("" + phoneNumber));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(custom);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUserUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ValidationProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCustomer(storeId: number | undefined, phoneNumber: string | null | undefined, httpContext?: HttpContext): Observable<FileResponse> {
        let url_ = this.baseUrl + "/customer?";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        if (phoneNumber !== undefined && phoneNumber !== null)
            url_ += "phoneNumber=" + encodeURIComponent("" + phoneNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetCustomer(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ProductClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://jr8qjxj4-44373.asse.devtunnels.ms";
    }

    /**
     * 根据条形码获取当前公司下所有店铺符合条件的商品详细数据
     * @param companyId (optional) 公司id
     * @param barcode (optional) 商品条形码
     */
    getProductDetails(companyId: string | null | undefined, barcode: string | null | undefined, httpContext?: HttpContext): Observable<CompanyProductsDTO> {
        let url_ = this.baseUrl + "/api/Product/details?";
        if (companyId !== undefined && companyId !== null)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        if (barcode !== undefined && barcode !== null)
            url_ += "barcode=" + encodeURIComponent("" + barcode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyProductsDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyProductsDTO>;
        }));
    }

    protected processGetProductDetails(response: HttpResponseBase): Observable<CompanyProductsDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyProductsDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 根据条形码获取当前公司下所有店铺符合条件的商品基本数据
     * @param companyId (optional) 公司ID
     * @param barcode (optional) 条形码
     */
    getBasicProductInfo(companyId: string | null | undefined, barcode: string | null | undefined, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/Product/basic-info?";
        if (companyId !== undefined && companyId !== null)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        if (barcode !== undefined && barcode !== null)
            url_ += "barcode=" + encodeURIComponent("" + barcode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBasicProductInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBasicProductInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetBasicProductInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 获取商品图片
     * @param storeId (optional) 
     * @param imageId (optional) 
     */
    getProductImage(storeId: number | undefined, imageId: string | null | undefined, httpContext?: HttpContext): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Product/Image?";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        if (imageId !== undefined && imageId !== null)
            url_ += "imageId=" + encodeURIComponent("" + imageId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetProductImage(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ProductImagesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://jr8qjxj4-44373.asse.devtunnels.ms";
    }

    /**
     * 获取数据库商品图片
     * @param storeAccessKey (optional) 
     */
    get(pluUpc: string | null, storeAccessKey: string | null | undefined, httpContext?: HttpContext): Observable<FileResponse> {
        let url_ = this.baseUrl + "/ProductImages/{pluUpc}?";
        if (pluUpc === undefined || pluUpc === null)
            throw new Error("The parameter 'pluUpc' must be defined.");
        url_ = url_.replace("{pluUpc}", encodeURIComponent("" + pluUpc));
        if (storeAccessKey !== undefined && storeAccessKey !== null)
            url_ += "storeAccessKey=" + encodeURIComponent("" + storeAccessKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 删除图片（目前仅用于测试）
     * @param storeAccessKey (optional) 
     */
    delete(pluUpc: string | null, storeAccessKey: string | null | undefined, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/ProductImages/{pluUpc}?";
        if (pluUpc === undefined || pluUpc === null)
            throw new Error("The parameter 'pluUpc' must be defined.");
        url_ = url_.replace("{pluUpc}", encodeURIComponent("" + pluUpc));
        if (storeAccessKey !== undefined && storeAccessKey !== null)
            url_ += "storeAccessKey=" + encodeURIComponent("" + storeAccessKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 同步商品图片
     * @param storeAccessKey (optional) 
     */
    synchronization(storeAccessKey: string | null | undefined, body: ProductImageSynchronizationBody, httpContext?: HttpContext): Observable<string[]> {
        let url_ = this.baseUrl + "/ProductImages/Synchronization?";
        if (storeAccessKey !== undefined && storeAccessKey !== null)
            url_ += "storeAccessKey=" + encodeURIComponent("" + storeAccessKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSynchronization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSynchronization(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processSynchronization(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ProductInfoCompletionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://jr8qjxj4-44373.asse.devtunnels.ms";
    }

    postProductInfoCompletion(request: BarcodesBody, httpContext?: HttpContext): Observable<BarcodeInfo[]> {
        let url_ = this.baseUrl + "/ProductInfoCompletion/plc";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostProductInfoCompletion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostProductInfoCompletion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BarcodeInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BarcodeInfo[]>;
        }));
    }

    protected processPostProductInfoCompletion(response: HttpResponseBase): Observable<BarcodeInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BarcodeInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductDescription(pLUUPC: string | null, httpContext?: HttpContext): Observable<ServiceResponseOfProductResult> {
        let url_ = this.baseUrl + "/ProductInfoCompletion/description/{PLUUPC}";
        if (pLUUPC === undefined || pLUUPC === null)
            throw new Error("The parameter 'pLUUPC' must be defined.");
        url_ = url_.replace("{PLUUPC}", encodeURIComponent("" + pLUUPC));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductDescription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductDescription(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceResponseOfProductResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceResponseOfProductResult>;
        }));
    }

    protected processGetProductDescription(response: HttpResponseBase): Observable<ServiceResponseOfProductResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceResponseOfProductResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ServiceResponseOfProductResult.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ProductManagementClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://jr8qjxj4-44373.asse.devtunnels.ms";
    }

    /**
     * 根据条件获取指定店铺下的商品条码(在商品条码和描述中只能二选其一)
     * @param stores (optional) 店铺ID
     * @param barcode (optional) 商品条码
     * @param description (optional) 商品描述
     * @param department (optional) 部门描述
     * @param vendor (optional) 
     * @param brand (optional) 
     * @param deptGroup (optional) 
     * @param excludeUniformValues (optional) 根据（Description,Department,Vendor,Brand,Tax,Price)排除多家店铺相同的数据,例子：new string[]{"Description","Department"}
     * @return 店铺条码数组
     */
    storeProductCode(stores: number[] | null | undefined, barcode: string | null | undefined, description: string | null | undefined, department: string | null | undefined, vendor: string | null | undefined, brand: string | null | undefined, deptGroup: string | null | undefined, excludeUniformValues: string[] | null | undefined, httpContext?: HttpContext): Observable<KeyValuePairedOfIntegerAndString[]> {
        let url_ = this.baseUrl + "/api/ProductManagement/product/code?";
        if (stores !== undefined && stores !== null)
            stores && stores.forEach(item => { url_ += "stores=" + encodeURIComponent("" + item) + "&"; });
        if (barcode !== undefined && barcode !== null)
            url_ += "barcode=" + encodeURIComponent("" + barcode) + "&";
        if (description !== undefined && description !== null)
            url_ += "description=" + encodeURIComponent("" + description) + "&";
        if (department !== undefined && department !== null)
            url_ += "department=" + encodeURIComponent("" + department) + "&";
        if (vendor !== undefined && vendor !== null)
            url_ += "vendor=" + encodeURIComponent("" + vendor) + "&";
        if (brand !== undefined && brand !== null)
            url_ += "brand=" + encodeURIComponent("" + brand) + "&";
        if (deptGroup !== undefined && deptGroup !== null)
            url_ += "deptGroup=" + encodeURIComponent("" + deptGroup) + "&";
        if (excludeUniformValues !== undefined && excludeUniformValues !== null)
            excludeUniformValues && excludeUniformValues.forEach(item => { url_ += "excludeUniformValues=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStoreProductCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStoreProductCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<KeyValuePairedOfIntegerAndString[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<KeyValuePairedOfIntegerAndString[]>;
        }));
    }

    protected processStoreProductCode(response: HttpResponseBase): Observable<KeyValuePairedOfIntegerAndString[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(KeyValuePairedOfIntegerAndString.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 更新商品信息
     */
    updateProduct(updateProduct: UpdateProductDto, httpContext?: HttpContext): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductManagement/product/code";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateProduct);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdateProduct(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 根据条形码获取指定店铺下的商品信息
     */
    storeProductCodeInfo(storeCodes: KeyValuePairedOfIntegerAndString[], httpContext?: HttpContext): Observable<ProductInfoDto[]> {
        let url_ = this.baseUrl + "/api/ProductManagement/product/code/info";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(storeCodes);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStoreProductCodeInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStoreProductCodeInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductInfoDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductInfoDto[]>;
        }));
    }

    protected processStoreProductCodeInfo(response: HttpResponseBase): Observable<ProductInfoDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductInfoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getDpetBindTaxIds(storeId: number | undefined, deptId: number | undefined, httpContext?: HttpContext): Observable<string[]> {
        let url_ = this.baseUrl + "/api/ProductManagement/product/dept/tax/ids?";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        if (deptId === null)
            throw new Error("The parameter 'deptId' cannot be null.");
        else if (deptId !== undefined)
            url_ += "deptId=" + encodeURIComponent("" + deptId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDpetBindTaxIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDpetBindTaxIds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetDpetBindTaxIds(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ProductReportClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://jr8qjxj4-44373.asse.devtunnels.ms";
    }

    /**
     * 获取所有店铺正在出售的商品
     * @param storeArrays (optional) 
     * @param nonmovementDate (optional) 
     * @return 请求成功
     */
    getAllStoreProducts(storeArrays: number[] | null | undefined, nonmovementDate: Date | undefined, httpContext?: HttpContext): Observable<ProductReportResponse> {
        let url_ = this.baseUrl + "/movement/products?";
        if (storeArrays !== undefined && storeArrays !== null)
            storeArrays && storeArrays.forEach(item => { url_ += "StoreArrays=" + encodeURIComponent("" + item) + "&"; });
        if (nonmovementDate === null)
            throw new Error("The parameter 'nonmovementDate' cannot be null.");
        else if (nonmovementDate !== undefined)
            url_ += "NonmovementDate=" + encodeURIComponent(nonmovementDate ? "" + nonmovementDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStoreProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStoreProducts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductReportResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductReportResponse>;
        }));
    }

    protected processGetAllStoreProducts(response: HttpResponseBase): Observable<ProductReportResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Not Fond", status, _responseText, _headers, result404);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductReportResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ReportClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://jr8qjxj4-44373.asse.devtunnels.ms";
    }

    getToken(requestDto: GetTokenRequestDto, httpContext?: HttpContext): Observable<string> {
        let url_ = this.baseUrl + "/api/Report/reportToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetToken(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getDiscountStoreCoupons(storeAccessKeys: string[] | null | undefined, beginDate: Date | undefined, endDate: Date | undefined, httpContext?: HttpContext): Observable<DiscountStoreCouponResponseDto> {
        let url_ = this.baseUrl + "/api/Report/discountStoreCoupons?";
        if (storeAccessKeys !== undefined && storeAccessKeys !== null)
            storeAccessKeys && storeAccessKeys.forEach(item => { url_ += "storeAccessKeys=" + encodeURIComponent("" + item) + "&"; });
        if (beginDate === null)
            throw new Error("The parameter 'beginDate' cannot be null.");
        else if (beginDate !== undefined)
            url_ += "beginDate=" + encodeURIComponent(beginDate ? "" + beginDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDiscountStoreCoupons(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDiscountStoreCoupons(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DiscountStoreCouponResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DiscountStoreCouponResponseDto>;
        }));
    }

    protected processGetDiscountStoreCoupons(response: HttpResponseBase): Observable<DiscountStoreCouponResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DiscountStoreCouponResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getStoreList(token: string | null | undefined, httpContext?: HttpContext): Observable<StoreListDto> {
        let url_ = this.baseUrl + "/api/Report/stores";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "ReportToken": token !== undefined && token !== null ? "" + token : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreListDto>;
        }));
    }

    protected processGetStoreList(response: HttpResponseBase): Observable<StoreListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StoreListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getHourSales(token: string | null | undefined, storeId: number | undefined, beginDate: Date | undefined, endDate: Date | undefined, httpContext?: HttpContext): Observable<HourlySalesResponseDto> {
        let url_ = this.baseUrl + "/api/Report/hourSales?";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        if (beginDate === null)
            throw new Error("The parameter 'beginDate' cannot be null.");
        else if (beginDate !== undefined)
            url_ += "beginDate=" + encodeURIComponent(beginDate ? "" + beginDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "ReportToken": token !== undefined && token !== null ? "" + token : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHourSales(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHourSales(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HourlySalesResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HourlySalesResponseDto>;
        }));
    }

    protected processGetHourSales(response: HttpResponseBase): Observable<HourlySalesResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HourlySalesResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getDepartmentGroupSales(token: string | null | undefined, storeId: number | undefined, beginDate: Date | undefined, endDate: Date | undefined, otherDepartment: boolean | undefined, httpContext?: HttpContext): Observable<DepartmentGroupSalesResponseDto> {
        let url_ = this.baseUrl + "/api/Report/departmentGroupSales?";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        if (beginDate === null)
            throw new Error("The parameter 'beginDate' cannot be null.");
        else if (beginDate !== undefined)
            url_ += "beginDate=" + encodeURIComponent(beginDate ? "" + beginDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (otherDepartment === null)
            throw new Error("The parameter 'otherDepartment' cannot be null.");
        else if (otherDepartment !== undefined)
            url_ += "OtherDepartment=" + encodeURIComponent("" + otherDepartment) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "ReportToken": token !== undefined && token !== null ? "" + token : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepartmentGroupSales(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepartmentGroupSales(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DepartmentGroupSalesResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DepartmentGroupSalesResponseDto>;
        }));
    }

    protected processGetDepartmentGroupSales(response: HttpResponseBase): Observable<DepartmentGroupSalesResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepartmentGroupSalesResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTenders(token: string | null | undefined, storeId: number | undefined, beginDate: Date | undefined, endDate: Date | undefined, httpContext?: HttpContext): Observable<TenderResponse> {
        let url_ = this.baseUrl + "/api/Report/tenders?";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        if (beginDate === null)
            throw new Error("The parameter 'beginDate' cannot be null.");
        else if (beginDate !== undefined)
            url_ += "beginDate=" + encodeURIComponent(beginDate ? "" + beginDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "ReportToken": token !== undefined && token !== null ? "" + token : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenderResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenderResponse>;
        }));
    }

    protected processGetTenders(response: HttpResponseBase): Observable<TenderResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenderResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSummary(token: string | null | undefined, storeId: number | undefined, beginDate: Date | undefined, endDate: Date | undefined, httpContext?: HttpContext): Observable<SummaryResponseDto> {
        let url_ = this.baseUrl + "/api/Report/summary?";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        if (beginDate === null)
            throw new Error("The parameter 'beginDate' cannot be null.");
        else if (beginDate !== undefined)
            url_ += "beginDate=" + encodeURIComponent(beginDate ? "" + beginDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "ReportToken": token !== undefined && token !== null ? "" + token : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSummary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SummaryResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SummaryResponseDto>;
        }));
    }

    protected processGetSummary(response: HttpResponseBase): Observable<SummaryResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SummaryResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sayHello(name: string | null | undefined, httpContext?: HttpContext): Observable<HelloReply2Dto> {
        let url_ = this.baseUrl + "/api/Report/SayHello?";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSayHello(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSayHello(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HelloReply2Dto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HelloReply2Dto>;
        }));
    }

    protected processSayHello(response: HttpResponseBase): Observable<HelloReply2Dto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HelloReply2Dto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class SettingConfigClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://jr8qjxj4-44373.asse.devtunnels.ms";
    }

    /**
     * 获取默认字段属性
     * @return Success!
     */
    getDefaultField(httpContext?: HttpContext): Observable<SettingConfigResponse> {
        let url_ = this.baseUrl + "/approval/DefaultField";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultField(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultField(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SettingConfigResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SettingConfigResponse>;
        }));
    }

    protected processGetDefaultField(response: HttpResponseBase): Observable<SettingConfigResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SettingConfigResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 修改属性
     * @param storeId 店铺id
     * @param config 属性基本信息
     * @return Success!
     */
    postSettingConfigField(storeId: number, config: SettingConfigResponse, httpContext?: HttpContext): Observable<FileResponse> {
        let url_ = this.baseUrl + "/approval/ModeifyField/{storeId}";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(config);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostSettingConfigField(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostSettingConfigField(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processPostSettingConfigField(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Not Found!", status, _responseText, _headers, result404);
            }));
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 获取所有字段
     * @param storeId 店铺id
     * @return Success!
     */
    getFieldName(storeId: number, httpContext?: HttpContext): Observable<SettingConfigResponse> {
        let url_ = this.baseUrl + "/approval/GetAllField/{storeId}";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFieldName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFieldName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SettingConfigResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SettingConfigResponse>;
        }));
    }

    protected processGetFieldName(response: HttpResponseBase): Observable<SettingConfigResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SettingConfigResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Not Found!", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 判断storeId 是否存在
     * @param storeId (optional) 
     * @return Success!
     */
    getStoreId(storeId: number | undefined, httpContext?: HttpContext): Observable<FileResponse> {
        let url_ = this.baseUrl + "/approval?";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetStoreId(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Not Found!", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class SharedTemplatesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://jr8qjxj4-44373.asse.devtunnels.ms";
    }

    /**
     * 获取所有的共享模板 Version 1.6
     * @return Success!
     */
    getSharedTemplate(httpContext?: HttpContext): Observable<SharedTemplate> {
        let url_ = this.baseUrl + "/approval/All/SharedTemplate";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSharedTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSharedTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SharedTemplate>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SharedTemplate>;
        }));
    }

    protected processGetSharedTemplate(response: HttpResponseBase): Observable<SharedTemplate> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Not Found!", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ValidationProblemDetails.fromJS(resultData500);
            return throwException("Time out!", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SharedTemplate.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 搜索共享库中的模板
     * @param templateName (optional) 
     * @param guid (optional) 
     * @param storeId (optional) 
     * @return Success!
     */
    searchTemplate(templateName: string | null | undefined, guid: string | undefined, storeId: number | undefined, httpContext?: HttpContext): Observable<SearchTemplate> {
        let url_ = this.baseUrl + "/approval/Search/Template?";
        if (templateName !== undefined && templateName !== null)
            url_ += "templateName=" + encodeURIComponent("" + templateName) + "&";
        if (guid === null)
            throw new Error("The parameter 'guid' cannot be null.");
        else if (guid !== undefined)
            url_ += "guid=" + encodeURIComponent("" + guid) + "&";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SearchTemplate>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SearchTemplate>;
        }));
    }

    protected processSearchTemplate(response: HttpResponseBase): Observable<SearchTemplate> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Not Found!", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ValidationProblemDetails.fromJS(resultData500);
            return throwException("Time out!", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchTemplate.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 获取商店名
     * @param storeId (optional) 
     */
    getStoreName(storeId: number | undefined, httpContext?: HttpContext): Observable<string> {
        let url_ = this.baseUrl + "/approval/StoreName?";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetStoreName(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ValidationProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class StoreChainCodeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://jr8qjxj4-44373.asse.devtunnels.ms";
    }

    /**
     * 根据条件获取指定店铺下的商品条码(在商品条码和描述中只能二选其一)
     * @param stores (optional) 店铺ID
     * @param type (optional) 查询类型( None:全部商品 | Normal:普通商品 | Internal:内部商品
     * @param isIncludeChainCode (optional) 是否包含供应链码(True: 只返回供应链码不为空 | False: 只返回供应链码为空 | null: 返回所有)
     * @param barcode (optional) 商品条码
     * @param description (optional) 商品描述
     * @param department (optional) 部门描述
     * @param filterSharedProducts (optional) 是否过滤出多家店铺共同拥有的商品(True: 过滤 | False： 不过滤)
     * @return 店铺条码数组
     */
    storeProductCode(stores: number[] | null | undefined, type: StoreChainCodeType | undefined, isIncludeChainCode: boolean | null | undefined, barcode: string | null | undefined, description: string | null | undefined, department: string | null | undefined, filterSharedProducts: boolean | undefined, httpContext?: HttpContext): Observable<KeyValuePairedOfIntegerAndString[]> {
        let url_ = this.baseUrl + "/api/StoreChainCode/product/code?";
        if (stores !== undefined && stores !== null)
            stores && stores.forEach(item => { url_ += "stores=" + encodeURIComponent("" + item) + "&"; });
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (isIncludeChainCode !== undefined && isIncludeChainCode !== null)
            url_ += "isIncludeChainCode=" + encodeURIComponent("" + isIncludeChainCode) + "&";
        if (barcode !== undefined && barcode !== null)
            url_ += "barcode=" + encodeURIComponent("" + barcode) + "&";
        if (description !== undefined && description !== null)
            url_ += "description=" + encodeURIComponent("" + description) + "&";
        if (department !== undefined && department !== null)
            url_ += "department=" + encodeURIComponent("" + department) + "&";
        if (filterSharedProducts === null)
            throw new Error("The parameter 'filterSharedProducts' cannot be null.");
        else if (filterSharedProducts !== undefined)
            url_ += "filterSharedProducts=" + encodeURIComponent("" + filterSharedProducts) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStoreProductCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStoreProductCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<KeyValuePairedOfIntegerAndString[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<KeyValuePairedOfIntegerAndString[]>;
        }));
    }

    protected processStoreProductCode(response: HttpResponseBase): Observable<KeyValuePairedOfIntegerAndString[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(KeyValuePairedOfIntegerAndString.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 根据条形码获取指定店铺下的商品信息
     */
    storeProductCodeInfo(storeCodes: KeyValuePairedOfIntegerAndString[], httpContext?: HttpContext): Observable<StoreChainCodeInfo[]> {
        let url_ = this.baseUrl + "/api/StoreChainCode/product/code/info";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(storeCodes);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStoreProductCodeInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStoreProductCodeInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreChainCodeInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreChainCodeInfo[]>;
        }));
    }

    protected processStoreProductCodeInfo(response: HttpResponseBase): Observable<StoreChainCodeInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StoreChainCodeInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 更新多家店铺中内部商品的唯一内部条码
     * @param isUpdatePLuEnabled (optional) 是否启用更新PLU表中这件商品本身(Desc|Department)
     */
    updateProductInfo(isUpdatePLuEnabled: boolean | undefined, chainCodeDto: UpdateProductChainCodeDto, httpContext?: HttpContext): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/StoreChainCode/product/code/info?";
        if (isUpdatePLuEnabled === null)
            throw new Error("The parameter 'isUpdatePLuEnabled' cannot be null.");
        else if (isUpdatePLuEnabled !== undefined)
            url_ += "isUpdatePLuEnabled=" + encodeURIComponent("" + isUpdatePLuEnabled) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(chainCodeDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProductInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProductInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdateProductInfo(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 是否允许更新
     * @param stores (optional) 店铺
     * @param department (optional) 部门
     * @return True：允许更新 | False：不允许更新
     */
    isUpdatePermitted(stores: number[] | null | undefined, department: string | null | undefined, httpContext?: HttpContext): Observable<KeyValuePairedOfIntegerAndBoolean[]> {
        let url_ = this.baseUrl + "/api/StoreChainCode/product/code/update/is-permitted?";
        if (stores !== undefined && stores !== null)
            stores && stores.forEach(item => { url_ += "stores=" + encodeURIComponent("" + item) + "&"; });
        if (department !== undefined && department !== null)
            url_ += "department=" + encodeURIComponent("" + department) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUpdatePermitted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUpdatePermitted(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<KeyValuePairedOfIntegerAndBoolean[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<KeyValuePairedOfIntegerAndBoolean[]>;
        }));
    }

    protected processIsUpdatePermitted(response: HttpResponseBase): Observable<KeyValuePairedOfIntegerAndBoolean[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(KeyValuePairedOfIntegerAndBoolean.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class StoreDataCloneClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://jr8qjxj4-44373.asse.devtunnels.ms";
    }

    /**
     * 克隆商品数据
     */
    productClone(dto: StoreDataCloneBody, httpContext?: HttpContext): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/StoreDataClone/clone/product";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductClone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductClone(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processProductClone(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 克隆商品属性
     */
    productAttributeClone(dto: StoreDataCloneBody, httpContext?: HttpContext): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/StoreDataClone/clone/product/attribute";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductAttributeClone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductAttributeClone(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processProductAttributeClone(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getBarCode(storeId: number | undefined, departments: string[] | null | undefined, httpContext?: HttpContext): Observable<string[]> {
        let url_ = this.baseUrl + "/api/StoreDataClone/clone/barcodes?";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        if (departments !== undefined && departments !== null)
            departments && departments.forEach(item => { url_ += "departments=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBarCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBarCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetBarCode(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class StoreInventoryClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://jr8qjxj4-44373.asse.devtunnels.ms";
    }

    /**
     * 多家店铺：搜索商品条码
     * @param storeIdList (optional) 店铺ID列表
     * @param searchType (optional) 搜索类型 (Text / UPC)
     * @param brand (optional) 品牌
     * @param vendor (optional) 供货商
     * @param department (optional) 部门
     * @param searchText (optional) 搜索内容
     * @param isVisible (optional) 只返回库存(>=0)的商品(Default: False)
     * @param minInventory (optional) 最小库存数量(Default: null)
     */
    getBarCodeList(storeIdList: number[] | null | undefined, searchType: SearchType | undefined, brand: string | null | undefined, vendor: string | null | undefined, department: string | null | undefined, searchText: string | null | undefined, isVisible: boolean | undefined, minInventory: number | null | undefined, httpContext?: HttpContext): Observable<string[]> {
        let url_ = this.baseUrl + "/api/StoreInventory/barCodeList?";
        if (storeIdList !== undefined && storeIdList !== null)
            storeIdList && storeIdList.forEach(item => { url_ += "StoreIdList=" + encodeURIComponent("" + item) + "&"; });
        if (searchType === null)
            throw new Error("The parameter 'searchType' cannot be null.");
        else if (searchType !== undefined)
            url_ += "SearchType=" + encodeURIComponent("" + searchType) + "&";
        if (brand !== undefined && brand !== null)
            url_ += "brand=" + encodeURIComponent("" + brand) + "&";
        if (vendor !== undefined && vendor !== null)
            url_ += "vendor=" + encodeURIComponent("" + vendor) + "&";
        if (department !== undefined && department !== null)
            url_ += "department=" + encodeURIComponent("" + department) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (isVisible === null)
            throw new Error("The parameter 'isVisible' cannot be null.");
        else if (isVisible !== undefined)
            url_ += "isVisible=" + encodeURIComponent("" + isVisible) + "&";
        if (minInventory !== undefined && minInventory !== null)
            url_ += "minInventory=" + encodeURIComponent("" + minInventory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBarCodeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBarCodeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetBarCodeList(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 多家店铺：商品库存信息
     */
    getStoreInventorys(request: SearchStoreInventroyRequest, httpContext?: HttpContext): Observable<StoreInventoryDto[]> {
        let url_ = this.baseUrl + "/api/StoreInventory/inventories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreInventorys(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreInventorys(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreInventoryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreInventoryDto[]>;
        }));
    }

    protected processGetStoreInventorys(response: HttpResponseBase): Observable<StoreInventoryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StoreInventoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 获取所有商品转移请求订单
     * @param storeIdList (optional) 
     * @param queryDays (optional) 查询天数范围(默认30天)
     * @param isReceived (optional) 是否包含已收到的请求(默认不包含)
     */
    getAllTransferRequest(storeIdList: number[] | null | undefined, queryDays: number | undefined, isReceived: boolean | undefined, httpContext?: HttpContext): Observable<GetTransferResponseDto[]> {
        let url_ = this.baseUrl + "/api/StoreInventory/transferRequest?";
        if (storeIdList !== undefined && storeIdList !== null)
            storeIdList && storeIdList.forEach(item => { url_ += "storeIdList=" + encodeURIComponent("" + item) + "&"; });
        if (queryDays === null)
            throw new Error("The parameter 'queryDays' cannot be null.");
        else if (queryDays !== undefined)
            url_ += "queryDays=" + encodeURIComponent("" + queryDays) + "&";
        if (isReceived === null)
            throw new Error("The parameter 'isReceived' cannot be null.");
        else if (isReceived !== undefined)
            url_ += "isReceived=" + encodeURIComponent("" + isReceived) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTransferRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTransferRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTransferResponseDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTransferResponseDto[]>;
        }));
    }

    protected processGetAllTransferRequest(response: HttpResponseBase): Observable<GetTransferResponseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetTransferResponseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 创建商品转移请求订单
     */
    createTransferRequest(createTransferRequest: CreateTransferRequestDto, httpContext?: HttpContext): Observable<string> {
        let url_ = this.baseUrl + "/api/StoreInventory/transferRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createTransferRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTransferRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTransferRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreateTransferRequest(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 删除多个商品转移请求订单
     */
    deleteTransferRequest(transferRequestIdList: string[], httpContext?: HttpContext): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/StoreInventory/transferRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(transferRequestIdList);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTransferRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTransferRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteTransferRequest(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 搜索转移请求订单
     * @param requestId (optional) 订单id
     */
    searchTransferRequest(requestId: string | undefined, httpContext?: HttpContext): Observable<GetTransferResponseDto> {
        let url_ = this.baseUrl + "/api/StoreInventory/transferRequest/search?";
        if (requestId === null)
            throw new Error("The parameter 'requestId' cannot be null.");
        else if (requestId !== undefined)
            url_ += "requestId=" + encodeURIComponent("" + requestId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchTransferRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchTransferRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTransferResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTransferResponseDto>;
        }));
    }

    protected processSearchTransferRequest(response: HttpResponseBase): Observable<GetTransferResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTransferResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 更新转移请求订单状态
     * @param transferRequestId (optional) 转移请求ID
     * @param status (optional) 订单状态
     * @param userId (optional) 
     */
    updateTransferRequestStatus(transferRequestId: string | undefined, status: TransferStatus | undefined, userId: number | undefined, httpContext?: HttpContext): Observable<GetTransferResponseDto> {
        let url_ = this.baseUrl + "/api/StoreInventory/transferRequest/status?";
        if (transferRequestId === null)
            throw new Error("The parameter 'transferRequestId' cannot be null.");
        else if (transferRequestId !== undefined)
            url_ += "transferRequestId=" + encodeURIComponent("" + transferRequestId) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTransferRequestStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTransferRequestStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTransferResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTransferResponseDto>;
        }));
    }

    protected processUpdateTransferRequestStatus(response: HttpResponseBase): Observable<GetTransferResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTransferResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 更新商品仓库的库存
     */
    updateStoreInvertory(bodyDto: UpdateStoreInventoryDto, httpContext?: HttpContext): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/StoreInventory/transferRequest/update-store-warehouse-inventory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bodyDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStoreInvertory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStoreInvertory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdateStoreInvertory(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 更新商品转移请求订单中的商品数据
     * @param transferRequestID (optional) 转移请求ID
     * @param productInfos 商品信息列表
     */
    updateTransferProductInfo(transferRequestID: string | undefined, productInfos: TransferProductInfo[], httpContext?: HttpContext): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/StoreInventory/transferRequest/products?";
        if (transferRequestID === null)
            throw new Error("The parameter 'transferRequestID' cannot be null.");
        else if (transferRequestID !== undefined)
            url_ += "transferRequestID=" + encodeURIComponent("" + transferRequestID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(productInfos);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTransferProductInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTransferProductInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdateTransferProductInfo(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 更新转移请求中商品实际收到的货品数量
     * @param transferRequestID (optional) 转移请求ID
     * @param barCode (optional) 当前订单中的商品条码
     * @param receiveQty (optional) 商品实际收到的数量
     */
    updateTransferProductReceivedQty(transferRequestID: string | undefined, barCode: string | null | undefined, receiveQty: number | null | undefined, httpContext?: HttpContext): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/StoreInventory/transferRequest/products/receive/qty?";
        if (transferRequestID === null)
            throw new Error("The parameter 'transferRequestID' cannot be null.");
        else if (transferRequestID !== undefined)
            url_ += "transferRequestID=" + encodeURIComponent("" + transferRequestID) + "&";
        if (barCode !== undefined && barCode !== null)
            url_ += "barCode=" + encodeURIComponent("" + barCode) + "&";
        if (receiveQty !== undefined && receiveQty !== null)
            url_ += "receiveQty=" + encodeURIComponent("" + receiveQty) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTransferProductReceivedQty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTransferProductReceivedQty(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdateTransferProductReceivedQty(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class StoreReportClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://jr8qjxj4-44373.asse.devtunnels.ms";
    }

    /**
     * 部门数据比较（按照组比较并且查询）
     * @param reportType (optional) 
     */
    getDepartmentCompaeison(reportType: ReportType | undefined, body: DepartmentBodys, httpContext?: HttpContext): Observable<DepartmentDifferenceReportDto[]> {
        let url_ = this.baseUrl + "/api/StoreReport/department/CompaeisonReport?";
        if (reportType === null)
            throw new Error("The parameter 'reportType' cannot be null.");
        else if (reportType !== undefined)
            url_ += "reportType=" + encodeURIComponent("" + reportType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepartmentCompaeison(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepartmentCompaeison(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DepartmentDifferenceReportDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DepartmentDifferenceReportDto[]>;
        }));
    }

    protected processGetDepartmentCompaeison(response: HttpResponseBase): Observable<DepartmentDifferenceReportDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DepartmentDifferenceReportDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 分组总和差异化报表
     */
    getGroupCompaeisonReport(body: DepartmentBodys, httpContext?: HttpContext): Observable<GroupDifferenceReportDto> {
        let url_ = this.baseUrl + "/api/StoreReport/group/CompaeisonReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGroupCompaeisonReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGroupCompaeisonReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GroupDifferenceReportDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GroupDifferenceReportDto>;
        }));
    }

    protected processGetGroupCompaeisonReport(response: HttpResponseBase): Observable<GroupDifferenceReportDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GroupDifferenceReportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 店铺数据报表
     */
    getStoreGroupComparison(body: DepartmentBody, httpContext?: HttpContext): Observable<StoreGroupComparisonDto[]> {
        let url_ = this.baseUrl + "/api/StoreReport/store/CompaeisonReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreGroupComparison(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreGroupComparison(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreGroupComparisonDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreGroupComparisonDto[]>;
        }));
    }

    protected processGetStoreGroupComparison(response: HttpResponseBase): Observable<StoreGroupComparisonDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StoreGroupComparisonDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class StoreSalesRankingClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://jr8qjxj4-44373.asse.devtunnels.ms";
    }

    /**
     * 获取店铺商品销售榜
     * @param stores (optional) 店铺
     * @param begin (optional) 起始
     * @param end (optional) 结束
     * @param salesRankingCount (optional) 榜单数
     * @param department (optional) 部门
     */
    getSalesRanking(stores: number[] | null | undefined, begin: string | null | undefined, end: string | null | undefined, salesRankingCount: number | undefined, department: string | null | undefined, httpContext?: HttpContext): Observable<SalesRankingDto[]> {
        let url_ = this.baseUrl + "/api/StoreSalesRanking?";
        if (stores !== undefined && stores !== null)
            stores && stores.forEach(item => { url_ += "stores=" + encodeURIComponent("" + item) + "&"; });
        if (begin !== undefined && begin !== null)
            url_ += "begin=" + encodeURIComponent("" + begin) + "&";
        if (end !== undefined && end !== null)
            url_ += "end=" + encodeURIComponent("" + end) + "&";
        if (salesRankingCount === null)
            throw new Error("The parameter 'salesRankingCount' cannot be null.");
        else if (salesRankingCount !== undefined)
            url_ += "salesRankingCount=" + encodeURIComponent("" + salesRankingCount) + "&";
        if (department !== undefined && department !== null)
            url_ += "department=" + encodeURIComponent("" + department) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSalesRanking(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalesRanking(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalesRankingDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalesRankingDto[]>;
        }));
    }

    protected processGetSalesRanking(response: HttpResponseBase): Observable<SalesRankingDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SalesRankingDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class StoresClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://jr8qjxj4-44373.asse.devtunnels.ms";
    }

    /**
     * Created Stores
     * @param companyId (optional) Company Id
     * @param storesDTO Stores
     * @return Created Success!
     */
    createdStore(companyId: number | undefined, storesDTO: StoresDTO, httpContext?: HttpContext): Observable<StoresDTO> {
        let url_ = this.baseUrl + "/api/Stores?";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(storesDTO);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatedStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatedStore(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoresDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoresDTO>;
        }));
    }

    protected processCreatedStore(response: HttpResponseBase): Observable<StoresDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StoresDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("StoreName\u5df2\u7ecf\u5b58\u5728\u6216\u8005DataMinerAccessKey\u5df2\u7ecf\u5b58\u5728", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("\u4f20\u9012\u7684\u53c2\u6570\u4e2d\u5305\u542b\u91cd\u590d\u7684StoreName\u6216\u8005\u91cd\u590d\u7684DataMinerAccessKey", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete Stores
     * @param companyId (optional) Company Id
     * @param storesId Store Id List
     * @return Delete Success!
     */
    deleteStore(companyId: number | undefined, storesId: number[], httpContext?: HttpContext): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Stores?";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(storesId);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteStore(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteStore(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return _observableOf(result204);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("Delete Failure!", status, _responseText, _headers, result409);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Not Found!", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update Store
     * @param companyId (optional) Company Id
     * @return Update Success!
     */
    updateStore(companyId: number | undefined, storeDTO: StoreDTO, httpContext?: HttpContext): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Stores?";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(storeDTO);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStore(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdateStore(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return _observableOf(result204);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : <any>null;
    
            return throwException("\u4fee\u6539\u7684\u5e97\u94fa\u5185\u5bb9\u5305\u542b\u5df2\u7ecf\u5b58\u5728\u7684!", status, _responseText, _headers, result409);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Not Found!", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("\u4f20\u9012\u7684\u53c2\u6570\u4e2d\u5305\u542b\u91cd\u590d\u7684StoreName\u6216\u8005\u91cd\u590d\u7684DataMinerAccessKey!", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get Stores
     * @param companyId (optional) Company Id
     * @return 请求成功，返回店铺集合
     */
    getCompanyStore(companyId: number | undefined, httpContext?: HttpContext): Observable<StoresDTO> {
        let url_ = this.baseUrl + "/api/Stores?";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompanyStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompanyStore(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoresDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoresDTO>;
        }));
    }

    protected processGetCompanyStore(response: HttpResponseBase): Observable<StoresDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return throwException("\u8bf7\u6c42\u6210\u529f\uff0c\u4f46\u5f53\u524d\u516c\u53f8\u65d7\u4e0b\u6ca1\u6709\u5e97\u94fa", status, _responseText, _headers, result204);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StoresDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Not Found!", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getStoreId(encryptedId: string | null | undefined, httpContext?: HttpContext): Observable<number> {
        let url_ = this.baseUrl + "/api/Stores/id?";
        if (encryptedId !== undefined && encryptedId !== null)
            url_ += "encryptedId=" + encodeURIComponent("" + encryptedId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetStoreId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class TemporaryTokenClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://jr8qjxj4-44373.asse.devtunnels.ms";
    }

    /**
     * 生成带有时效性的Token
     * @param storeId 商店ID
     * @param userId 用户ID
     * @param eventId 事件ID
     * @param devmode (optional) 模式{true：开发模式 false：生产模式}
     */
    getTemporaryToken(storeId: number, userId: number, eventId: number, devmode: boolean | undefined, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/approval/{storeId}/{userId}/{eventId}?";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        if (devmode === null)
            throw new Error("The parameter 'devmode' cannot be null.");
        else if (devmode !== undefined)
            url_ += "devmode=" + encodeURIComponent("" + devmode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemporaryToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemporaryToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetTemporaryToken(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 302) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result302: any = null;
            let resultData302 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result302 = resultData302 !== undefined ? resultData302 : <any>null;
    
            return throwException("\u91cd\u5b9a\u5411", status, _responseText, _headers, result302);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Not Found!", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 验证Token和Token的时效性
     * @param temporarytoken token
     * @return 返回事件内容
     */
    getEventContent(temporarytoken: string | null, httpContext?: HttpContext): Observable<EventResponse> {
        let url_ = this.baseUrl + "/approval/eventContent/{temporarytoken}";
        if (temporarytoken === undefined || temporarytoken === null)
            throw new Error("The parameter 'temporarytoken' must be defined.");
        url_ = url_.replace("{temporarytoken}", encodeURIComponent("" + temporarytoken));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEventContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEventContent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EventResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EventResponse>;
        }));
    }

    protected processGetEventContent(response: HttpResponseBase): Observable<EventResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("token\u4e3a\u7a7a\u6216Token\u4e0d\u5b58\u5728", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ValidationProblemDetails.fromJS(resultData401);
            return throwException("token \u8fc7\u671f", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 授权
     * @param temporarytoken token
     * @param eventApproved (optional) 状态
     * @return Token验证成功
     */
    postAuthorize(temporarytoken: string | null, eventApproved: EventApproved | undefined, httpContext?: HttpContext): Observable<EventResponse> {
        let url_ = this.baseUrl + "/approval/response/{temporarytoken}?";
        if (temporarytoken === undefined || temporarytoken === null)
            throw new Error("The parameter 'temporarytoken' must be defined.");
        url_ = url_.replace("{temporarytoken}", encodeURIComponent("" + temporarytoken));
        if (eventApproved === null)
            throw new Error("The parameter 'eventApproved' cannot be null.");
        else if (eventApproved !== undefined)
            url_ += "eventApproved=" + encodeURIComponent("" + eventApproved) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostAuthorize(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostAuthorize(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EventResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EventResponse>;
        }));
    }

    protected processPostAuthorize(response: HttpResponseBase): Observable<EventResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ValidationProblemDetails.fromJS(resultData409);
            return throwException("\u5e76\u53d1\u51b2\u7a81", status, _responseText, _headers, result409);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("token\u65e0\u6548\u6216\u6ca1\u6709\u4f20\u5165token", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ValidationProblemDetails.fromJS(resultData401);
            return throwException("token\u8fc7\u671f", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class UserClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://jr8qjxj4-44373.asse.devtunnels.ms";
    }

    getUsers(companyName: string | null | undefined, httpContext?: HttpContext): Observable<UsersDto[]> {
        let url_ = this.baseUrl + "/api/User?";
        if (companyName !== undefined && companyName !== null)
            url_ += "companyName=" + encodeURIComponent("" + companyName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UsersDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UsersDto[]>;
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<UsersDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UsersDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateUser(userId: number | undefined, newUser: UpdateUser, httpContext?: HttpContext): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/User?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newUser);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdateUser(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteUser(userId: number | undefined, httpContext?: HttpContext): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/User?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 注册用户接口
     * @param obfuscatedDto 混淆后的注册信息(传入时先转换JSON，再转换成Base64)
     */
    registerUser(obfuscatedDto: string, httpContext?: HttpContext): Observable<number> {
        let url_ = this.baseUrl + "/api/User/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(obfuscatedDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processRegisterUser(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class Discount implements IDiscount {
    code?: string | undefined;
    storeName?: string | undefined;
    total?: number;
    qty?: number;
    description?: string | undefined;

    constructor(data?: IDiscount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.storeName = _data["storeName"];
            this.total = _data["total"];
            this.qty = _data["qty"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): Discount {
        data = typeof data === 'object' ? data : {};
        let result = new Discount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["storeName"] = this.storeName;
        data["total"] = this.total;
        data["qty"] = this.qty;
        data["description"] = this.description;
        return data;
    }
}

export interface IDiscount {
    code?: string | undefined;
    storeName?: string | undefined;
    total?: number;
    qty?: number;
    description?: string | undefined;
}

export class StoreConnection implements IStoreConnection {
    storeId?: number;
    storeName?: string | undefined;
    commpanyName?: string | undefined;
    created?: Date;
    status?: string | undefined;
    accessKey?: string | undefined;

    constructor(data?: IStoreConnection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            this.storeName = _data["storeName"];
            this.commpanyName = _data["commpanyName"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.accessKey = _data["accessKey"];
        }
    }

    static fromJS(data: any): StoreConnection {
        data = typeof data === 'object' ? data : {};
        let result = new StoreConnection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["storeName"] = this.storeName;
        data["commpanyName"] = this.commpanyName;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["accessKey"] = this.accessKey;
        return data;
    }
}

export interface IStoreConnection {
    storeId?: number;
    storeName?: string | undefined;
    commpanyName?: string | undefined;
    created?: Date;
    status?: string | undefined;
    accessKey?: string | undefined;
}

export class Department implements IDepartment {
    id?: number;
    departmentDesc?: string | undefined;

    constructor(data?: IDepartment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.departmentDesc = _data["departmentDesc"];
        }
    }

    static fromJS(data: any): Department {
        data = typeof data === 'object' ? data : {};
        let result = new Department();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["departmentDesc"] = this.departmentDesc;
        return data;
    }
}

export interface IDepartment {
    id?: number;
    departmentDesc?: string | undefined;
}

export class Vendor implements IVendor {
    id?: string;
    vendorDesc?: string | undefined;

    constructor(data?: IVendor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vendorDesc = _data["vendorDesc"];
        }
    }

    static fromJS(data: any): Vendor {
        data = typeof data === 'object' ? data : {};
        let result = new Vendor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vendorDesc"] = this.vendorDesc;
        return data;
    }
}

export interface IVendor {
    id?: string;
    vendorDesc?: string | undefined;
}

export class Brand implements IBrand {
    id?: number;
    brandDesc?: string | undefined;

    constructor(data?: IBrand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.brandDesc = _data["brandDesc"];
        }
    }

    static fromJS(data: any): Brand {
        data = typeof data === 'object' ? data : {};
        let result = new Brand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["brandDesc"] = this.brandDesc;
        return data;
    }
}

export interface IBrand {
    id?: number;
    brandDesc?: string | undefined;
}

export class TaxDto implements ITaxDto {
    id?: number;
    percentage?: number | undefined;
    descript?: string | undefined;

    constructor(data?: ITaxDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.percentage = _data["percentage"];
            this.descript = _data["descript"];
        }
    }

    static fromJS(data: any): TaxDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaxDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["percentage"] = this.percentage;
        data["descript"] = this.descript;
        return data;
    }
}

export interface ITaxDto {
    id?: number;
    percentage?: number | undefined;
    descript?: string | undefined;
}

export class DepartmentGroupDto implements IDepartmentGroupDto {
    id?: number | undefined;
    description?: string | undefined;

    constructor(data?: IDepartmentGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): DepartmentGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        return data;
    }
}

export interface IDepartmentGroupDto {
    id?: number | undefined;
    description?: string | undefined;
}

export class BundlesDto implements IBundlesDto {
    id?: string;
    description?: string | undefined;
    beginDate?: Date;
    endDate?: Date;
    forceBundleTotal?: number | undefined;

    constructor(data?: IBundlesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.beginDate = _data["beginDate"] ? new Date(_data["beginDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.forceBundleTotal = _data["forceBundleTotal"];
        }
    }

    static fromJS(data: any): BundlesDto {
        data = typeof data === 'object' ? data : {};
        let result = new BundlesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["beginDate"] = this.beginDate ? this.beginDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["forceBundleTotal"] = this.forceBundleTotal;
        return data;
    }
}

export interface IBundlesDto {
    id?: string;
    description?: string | undefined;
    beginDate?: Date;
    endDate?: Date;
    forceBundleTotal?: number | undefined;
}

export class CompanyDTO implements ICompanyDTO {
    id?: number;
    companyName?: string | undefined;

    constructor(data?: ICompanyDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyName = _data["companyName"];
        }
    }

    static fromJS(data: any): CompanyDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyName"] = this.companyName;
        return data;
    }
}

export interface ICompanyDTO {
    id?: number;
    companyName?: string | undefined;
}

export class CompaniesDTO implements ICompaniesDTO {
    companies?: CompanyDTO[] | undefined;

    constructor(data?: ICompaniesDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["companies"])) {
                this.companies = [] as any;
                for (let item of _data["companies"])
                    this.companies!.push(CompanyDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CompaniesDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CompaniesDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.companies)) {
            data["companies"] = [];
            for (let item of this.companies)
                data["companies"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICompaniesDTO {
    companies?: CompanyDTO[] | undefined;
}

export class Device implements IDevice {
    id?: string | undefined;
    name?: string | undefined;
    stationNumber?: string | undefined;
    storeName?: string | undefined;
    storeId?: number | undefined;

    constructor(data?: IDevice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.stationNumber = _data["stationNumber"];
            this.storeName = _data["storeName"];
            this.storeId = _data["storeId"];
        }
    }

    static fromJS(data: any): Device {
        data = typeof data === 'object' ? data : {};
        let result = new Device();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["stationNumber"] = this.stationNumber;
        data["storeName"] = this.storeName;
        data["storeId"] = this.storeId;
        return data;
    }
}

export interface IDevice {
    id?: string | undefined;
    name?: string | undefined;
    stationNumber?: string | undefined;
    storeName?: string | undefined;
    storeId?: number | undefined;
}

export class DeviceRecord implements IDeviceRecord {
    id?: number;
    beginTime?: Date;
    endTime?: Date;
    link?: string | undefined;
    deviceId?: string | undefined;

    constructor(data?: IDeviceRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.beginTime = _data["beginTime"] ? new Date(_data["beginTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>undefined;
            this.link = _data["link"];
            this.deviceId = _data["deviceId"];
        }
    }

    static fromJS(data: any): DeviceRecord {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceRecord();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["beginTime"] = this.beginTime ? this.beginTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["link"] = this.link;
        data["deviceId"] = this.deviceId;
        return data;
    }
}

export interface IDeviceRecord {
    id?: number;
    beginTime?: Date;
    endTime?: Date;
    link?: string | undefined;
    deviceId?: string | undefined;
}

export enum SupplierType {
    A = "A",
    S = "S",
    G = "G",
    H = "H",
    Q = "Q",
}

export abstract class IHeaderDictionary implements IIHeaderDictionary {
    item?: any[];
    contentLength?: number | undefined;

    constructor(data?: IIHeaderDictionary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Item"])) {
                this.item = [] as any;
                for (let item of _data["Item"])
                    this.item!.push(item);
            }
            this.contentLength = _data["ContentLength"];
        }
    }

    static fromJS(data: any): IHeaderDictionary {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IHeaderDictionary' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.item)) {
            data["Item"] = [];
            for (let item of this.item)
                data["Item"].push(item);
        }
        data["ContentLength"] = this.contentLength;
        return data;
    }
}

export interface IIHeaderDictionary {
    item?: any[];
    contentLength?: number | undefined;
}

export class TransferMixcodeBodyDto implements ITransferMixcodeBodyDto {
    currentStore!: number;
    targentStore!: number;
    mixcodes?: string[] | undefined;

    constructor(data?: ITransferMixcodeBodyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentStore = _data["currentStore"];
            this.targentStore = _data["targentStore"];
            if (Array.isArray(_data["mixcodes"])) {
                this.mixcodes = [] as any;
                for (let item of _data["mixcodes"])
                    this.mixcodes!.push(item);
            }
        }
    }

    static fromJS(data: any): TransferMixcodeBodyDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransferMixcodeBodyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentStore"] = this.currentStore;
        data["targentStore"] = this.targentStore;
        if (Array.isArray(this.mixcodes)) {
            data["mixcodes"] = [];
            for (let item of this.mixcodes)
                data["mixcodes"].push(item);
        }
        return data;
    }
}

export interface ITransferMixcodeBodyDto {
    currentStore: number;
    targentStore: number;
    mixcodes?: string[] | undefined;
}

export class AVSResponse implements IAVSResponse {
    response!: Response5;
    nbInternalTrace!: NationsInternalTrace;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;

    constructor(data?: IAVSResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.response = new Response5();
            this.nbInternalTrace = new NationsInternalTrace();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.response = _data["response"] ? Response5.fromJS(_data["response"]) : new Response5();
            this.nbInternalTrace = _data["nbInternalTrace"] ? NationsInternalTrace.fromJS(_data["nbInternalTrace"]) : new NationsInternalTrace();
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): AVSResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AVSResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["response"] = this.response ? this.response.toJSON() : <any>undefined;
        data["nbInternalTrace"] = this.nbInternalTrace ? this.nbInternalTrace.toJSON() : <any>undefined;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = (<any>this.additionalProperties)[key];
            }
        }
        return data;
    }
}

export interface IAVSResponse {
    response: Response5;
    nbInternalTrace: NationsInternalTrace;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;
}

export class Response5 implements IResponse5 {
    memberIDs?: Member[] | undefined;
    /** Additional status information in human readable form */
    status?: Response5Status | undefined;
    /** Additional status information */
    code?: Response5Code | undefined;
    details?: ExceptionDetails | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;

    constructor(data?: IResponse5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["memberIDs"])) {
                this.memberIDs = [] as any;
                for (let item of _data["memberIDs"])
                    this.memberIDs!.push(Member.fromJS(item));
            }
            this.status = _data["status"];
            this.code = _data["code"];
            this.details = _data["details"] ? ExceptionDetails.fromJS(_data["details"]) : <any>undefined;
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): Response5 {
        data = typeof data === 'object' ? data : {};
        let result = new Response5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.memberIDs)) {
            data["memberIDs"] = [];
            for (let item of this.memberIDs)
                data["memberIDs"].push(item.toJSON());
        }
        data["status"] = this.status;
        data["code"] = this.code;
        data["details"] = this.details ? this.details.toJSON() : <any>undefined;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = (<any>this.additionalProperties)[key];
            }
        }
        return data;
    }
}

export interface IResponse5 {
    memberIDs?: Member[] | undefined;
    /** Additional status information in human readable form */
    status?: Response5Status | undefined;
    /** Additional status information */
    code?: Response5Code | undefined;
    details?: ExceptionDetails | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;
}

export class Member implements IMember {
    /** The type of identifier for the member.  Note that the panHashId and trackOneId must be in SHA-256 UTF-8 Format. */
    uidType!: MemberUidType;
    /** The unique NationsBenefits identifier for the member. */
    uid!: string;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;

    constructor(data?: IMember) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.uidType = _data["uidType"];
            this.uid = _data["uid"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): Member {
        data = typeof data === 'object' ? data : {};
        let result = new Member();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["uidType"] = this.uidType;
        data["uid"] = this.uid;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = (<any>this.additionalProperties)[key];
            }
        }
        return data;
    }
}

export interface IMember {
    /** The type of identifier for the member.  Note that the panHashId and trackOneId must be in SHA-256 UTF-8 Format. */
    uidType: MemberUidType;
    /** The unique NationsBenefits identifier for the member. */
    uid: string;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;
}

export enum MemberUidType {
    PanHashId = "panHashId",
    TrackTwoId = "trackTwoId",
    TrackOneId = "trackOneId",
    KeyFobId = "keyFobId",
    QrCodeId = "qrCodeId",
}

export enum Response5Status {
    Account_validation_successful = "Account validation successful",
    Card_reported_lost_or_stolen = "Card reported lost or stolen",
    Member_not_found = "Member not found",
    Merchant_not_found = "Merchant not found",
    Missing_or_incorrect_data_provided_to_complete_the_validation_request = "Missing or incorrect data provided to complete the validation request",
    Card_not_activated = "Card not activated",
    Fraud_suspected = "Fraud suspected",
    Provided_CVV_incorrect = "Provided CVV incorrect",
    Provided_expiration_date_incorrect = "Provided expiration date incorrect",
    Provided_additional_info_incorrect = "Provided additional info incorrect",
    No_active_purses_found_for_this_member = "No active purses found for this member",
    Card_not_eligible_to_add_to_wallet = "Card not eligible to add to wallet",
    General_exception = "General exception",
}

export enum Response5Code {
    _000 = "000",
    _201 = "201",
    _202 = "202",
    _203 = "203",
    _204 = "204",
    _205 = "205",
    _206 = "206",
    _207 = "207",
    _208 = "208",
    _209 = "209",
    _210 = "210",
    _211 = "211",
    _300 = "300",
}

export class ExceptionDetails implements IExceptionDetails {
    /** Message element experiencing an error condition */
    propertyName!: any;
    /** Reason that message element is experiencing an error condition */
    errorMessage!: any;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;

    constructor(data?: IExceptionDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.propertyName = _data["propertyName"];
            this.errorMessage = _data["errorMessage"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): ExceptionDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ExceptionDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["propertyName"] = this.propertyName;
        data["errorMessage"] = this.errorMessage;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = (<any>this.additionalProperties)[key];
            }
        }
        return data;
    }
}

export interface IExceptionDetails {
    /** Message element experiencing an error condition */
    propertyName: any;
    /** Reason that message element is experiencing an error condition */
    errorMessage: any;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;
}

/** Object for internal NationsBenefits for developer and debugging purposes */
export class NationsInternalTrace implements INationsInternalTrace {
    /** Nations Internal Code used for debugging. */
    statusCode!: string;
    /** A unique ID generated by Nations for tracing. */
    traceId!: string;
    traceIdDate!: Date;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;

    constructor(data?: INationsInternalTrace) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.statusCode = _data["statusCode"];
            this.traceId = _data["traceId"];
            this.traceIdDate = _data["traceIdDate"] ? new Date(_data["traceIdDate"].toString()) : <any>undefined;
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): NationsInternalTrace {
        data = typeof data === 'object' ? data : {};
        let result = new NationsInternalTrace();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["statusCode"] = this.statusCode;
        data["traceId"] = this.traceId;
        data["traceIdDate"] = this.traceIdDate ? this.traceIdDate.toISOString() : <any>undefined;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = (<any>this.additionalProperties)[key];
            }
        }
        return data;
    }
}

/** Object for internal NationsBenefits for developer and debugging purposes */
export interface INationsInternalTrace {
    /** Nations Internal Code used for debugging. */
    statusCode: string;
    /** A unique ID generated by Nations for tracing. */
    traceId: string;
    traceIdDate: Date;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;
}

export class AVSRequest implements IAVSRequest {
    /** Card PAN in SHA-256 UTF-8 Format */
    pan!: string;
    /** Card CVV in SHA-256 UTF-8 Format */
    cvv!: string;
    /** Expiration date from card in format MM/YY */
    expiration!: string;
    additionalInfo!: AdditionalAVSData[];
    entryMode?: AVSRequestEntryMode | undefined;
    merchant!: Merchant;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;

    constructor(data?: IAVSRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.additionalInfo = [];
            this.merchant = new Merchant();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.pan = _data["pan"];
            this.cvv = _data["cvv"];
            this.expiration = _data["expiration"];
            if (Array.isArray(_data["additionalInfo"])) {
                this.additionalInfo = [] as any;
                for (let item of _data["additionalInfo"])
                    this.additionalInfo!.push(AdditionalAVSData.fromJS(item));
            }
            this.entryMode = _data["entryMode"];
            this.merchant = _data["merchant"] ? Merchant.fromJS(_data["merchant"]) : new Merchant();
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): AVSRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AVSRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["pan"] = this.pan;
        data["cvv"] = this.cvv;
        data["expiration"] = this.expiration;
        if (Array.isArray(this.additionalInfo)) {
            data["additionalInfo"] = [];
            for (let item of this.additionalInfo)
                data["additionalInfo"].push(item.toJSON());
        }
        data["entryMode"] = this.entryMode;
        data["merchant"] = this.merchant ? this.merchant.toJSON() : <any>undefined;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = (<any>this.additionalProperties)[key];
            }
        }
        return data;
    }
}

export interface IAVSRequest {
    /** Card PAN in SHA-256 UTF-8 Format */
    pan: string;
    /** Card CVV in SHA-256 UTF-8 Format */
    cvv: string;
    /** Expiration date from card in format MM/YY */
    expiration: string;
    additionalInfo: AdditionalAVSData[];
    entryMode?: AVSRequestEntryMode | undefined;
    merchant: Merchant;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;
}

export class AdditionalAVSData implements IAdditionalAVSData {
    dataType!: AdditionalAVSDataDataType;
    value!: string;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;

    constructor(data?: IAdditionalAVSData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.dataType = _data["dataType"];
            this.value = _data["value"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): AdditionalAVSData {
        data = typeof data === 'object' ? data : {};
        let result = new AdditionalAVSData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["dataType"] = this.dataType;
        data["value"] = this.value;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = (<any>this.additionalProperties)[key];
            }
        }
        return data;
    }
}

export interface IAdditionalAVSData {
    dataType: AdditionalAVSDataDataType;
    value: string;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;
}

export enum AdditionalAVSDataDataType {
    BillingZipCode = "billingZipCode",
    DateOfBirth = "dateOfBirth",
}

export enum AVSRequestEntryMode {
    Swipe = "swipe",
    Dip = "dip",
    Tap = "tap",
    Keyed = "keyed",
    Stored = "stored",
}

export class Merchant implements IMerchant {
    /** The unique identifier for the parent entity of the retailer or the processing entity. */
    entityId!: string;
    /** The unique identifier for the store. */
    storeId!: string;
    /** The identifier for the terminal. */
    terminalId?: string | undefined;
    /** The merchant category code. */
    mcc?: string | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;

    constructor(data?: IMerchant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.entityId = _data["entityId"];
            this.storeId = _data["storeId"];
            this.terminalId = _data["terminalId"];
            this.mcc = _data["mcc"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): Merchant {
        data = typeof data === 'object' ? data : {};
        let result = new Merchant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["entityId"] = this.entityId;
        data["storeId"] = this.storeId;
        data["terminalId"] = this.terminalId;
        data["mcc"] = this.mcc;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = (<any>this.additionalProperties)[key];
            }
        }
        return data;
    }
}

export interface IMerchant {
    /** The unique identifier for the parent entity of the retailer or the processing entity. */
    entityId: string;
    /** The unique identifier for the store. */
    storeId: string;
    /** The identifier for the terminal. */
    terminalId?: string | undefined;
    /** The merchant category code. */
    mcc?: string | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;
}

export class BIResponse implements IBIResponse {
    response!: Response6;
    nbInternalTrace!: NationsInternalTrace;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;

    constructor(data?: IBIResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.response = new Response6();
            this.nbInternalTrace = new NationsInternalTrace();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.response = _data["response"] ? Response6.fromJS(_data["response"]) : new Response6();
            this.nbInternalTrace = _data["nbInternalTrace"] ? NationsInternalTrace.fromJS(_data["nbInternalTrace"]) : new NationsInternalTrace();
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): BIResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BIResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["response"] = this.response ? this.response.toJSON() : <any>undefined;
        data["nbInternalTrace"] = this.nbInternalTrace ? this.nbInternalTrace.toJSON() : <any>undefined;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = (<any>this.additionalProperties)[key];
            }
        }
        return data;
    }
}

export interface IBIResponse {
    response: Response6;
    nbInternalTrace: NationsInternalTrace;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;
}

export class Response6 implements IResponse6 {
    balances?: BalanceItem[] | undefined;
    /** Additional status information in human readable form */
    status?: Response6Status | undefined;
    /** Additional status information */
    code?: Response6Code | undefined;
    applicationVersion?: string | undefined;
    details?: ExceptionDetails | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;

    constructor(data?: IResponse6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["balances"])) {
                this.balances = [] as any;
                for (let item of _data["balances"])
                    this.balances!.push(BalanceItem.fromJS(item));
            }
            this.status = _data["status"];
            this.code = _data["code"];
            this.applicationVersion = _data["applicationVersion"];
            this.details = _data["details"] ? ExceptionDetails.fromJS(_data["details"]) : <any>undefined;
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): Response6 {
        data = typeof data === 'object' ? data : {};
        let result = new Response6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.balances)) {
            data["balances"] = [];
            for (let item of this.balances)
                data["balances"].push(item.toJSON());
        }
        data["status"] = this.status;
        data["code"] = this.code;
        data["applicationVersion"] = this.applicationVersion;
        data["details"] = this.details ? this.details.toJSON() : <any>undefined;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = (<any>this.additionalProperties)[key];
            }
        }
        return data;
    }
}

export interface IResponse6 {
    balances?: BalanceItem[] | undefined;
    /** Additional status information in human readable form */
    status?: Response6Status | undefined;
    /** Additional status information */
    code?: Response6Code | undefined;
    applicationVersion?: string | undefined;
    details?: ExceptionDetails | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;
}

export class BalanceItem implements IBalanceItem {
    /** Internal purse identifier */
    purseId!: string;
    /** The human readable name of the purse (e.g. "OTC", "Healthy Living") */
    purseName?: string | undefined;
    /** Relative priority for this purse, lower is higher priority */
    priority?: number | undefined;
    /** The current amount in the purse. */
    amount!: number;
    /** The currency code for the transaction. */
    currencyCode?: BalanceItemCurrencyCode | undefined;
    /** The date when the balance will expire (e.g., "2023-07-19"). Note that these dates will be in ET.  This value may be omitted. */
    expiration?: string | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;

    constructor(data?: IBalanceItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.purseId = _data["purseId"];
            this.purseName = _data["purseName"];
            this.priority = _data["priority"];
            this.amount = _data["amount"];
            this.currencyCode = _data["currencyCode"];
            this.expiration = _data["expiration"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): BalanceItem {
        data = typeof data === 'object' ? data : {};
        let result = new BalanceItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["purseId"] = this.purseId;
        data["purseName"] = this.purseName;
        data["priority"] = this.priority;
        data["amount"] = this.amount;
        data["currencyCode"] = this.currencyCode;
        data["expiration"] = this.expiration;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = (<any>this.additionalProperties)[key];
            }
        }
        return data;
    }
}

export interface IBalanceItem {
    /** Internal purse identifier */
    purseId: string;
    /** The human readable name of the purse (e.g. "OTC", "Healthy Living") */
    purseName?: string | undefined;
    /** Relative priority for this purse, lower is higher priority */
    priority?: number | undefined;
    /** The current amount in the purse. */
    amount: number;
    /** The currency code for the transaction. */
    currencyCode?: BalanceItemCurrencyCode | undefined;
    /** The date when the balance will expire (e.g., "2023-07-19"). Note that these dates will be in ET.  This value may be omitted. */
    expiration?: string | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;
}

export enum BalanceItemCurrencyCode {
    USD = "USD",
    CAD = "CAD",
}

export enum Response6Status {
    Balance_inquiry_successful = "Balance inquiry successful",
    Card_reported_lost_or_stolen = "Card reported lost or stolen",
    Member_not_found = "Member not found",
    Merchant_not_found = "Merchant not found",
    Insufficient_data_provided_to_complete_the_balance_inquiry_request = "Insufficient data provided to complete the balance inquiry request",
    Card_not_activated = "Card not activated",
    Fraud_suspected = "Fraud suspected",
    No_active_purses_found_for_this_member = "No active purses found for this member",
    Card_not_enabled_for_balance_inquiry = "Card not enabled for balance inquiry",
    General_exception = "General exception",
}

export enum Response6Code {
    _000 = "000",
    _201 = "201",
    _202 = "202",
    _203 = "203",
    _204 = "204",
    _205 = "205",
    _206 = "206",
    _210 = "210",
    _211 = "211",
    _300 = "300",
}

export class BIRequest implements IBIRequest {
    member!: Member;
    merchant!: Merchant;
    applicationVersion?: string | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;

    constructor(data?: IBIRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.member = new Member();
            this.merchant = new Merchant();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.member = _data["member"] ? Member.fromJS(_data["member"]) : new Member();
            this.merchant = _data["merchant"] ? Merchant.fromJS(_data["merchant"]) : new Merchant();
            this.applicationVersion = _data["applicationVersion"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): BIRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BIRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["member"] = this.member ? this.member.toJSON() : <any>undefined;
        data["merchant"] = this.merchant ? this.merchant.toJSON() : <any>undefined;
        data["applicationVersion"] = this.applicationVersion;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = (<any>this.additionalProperties)[key];
            }
        }
        return data;
    }
}

export interface IBIRequest {
    member: Member;
    merchant: Merchant;
    applicationVersion?: string | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;
}

export class AnalyzeResponse implements IAnalyzeResponse {
    response!: Authorization;
    nbInternalTrace!: NationsInternalTrace;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;

    constructor(data?: IAnalyzeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.response = new Authorization();
            this.nbInternalTrace = new NationsInternalTrace();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.response = _data["response"] ? Authorization.fromJS(_data["response"]) : new Authorization();
            this.nbInternalTrace = _data["nbInternalTrace"] ? NationsInternalTrace.fromJS(_data["nbInternalTrace"]) : new NationsInternalTrace();
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): AnalyzeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AnalyzeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["response"] = this.response ? this.response.toJSON() : <any>undefined;
        data["nbInternalTrace"] = this.nbInternalTrace ? this.nbInternalTrace.toJSON() : <any>undefined;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = (<any>this.additionalProperties)[key];
            }
        }
        return data;
    }
}

export interface IAnalyzeResponse {
    response: Authorization;
    nbInternalTrace: NationsInternalTrace;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;
}

export class Authorization implements IAuthorization {
    /** Retailer generated unique identifier for the transaction. */
    merchantTransactionId!: string;
    /** The unique identifier for the transaction generated by Nations. */
    nationsBenefitsTransactionId!: string;
    /** The total authorized transaction amount (includes tax and refundable deposits). */
    authorizedTransactionAmount!: number;
    /** Authorization reason provides detailed information about the transaction status */
    status!: AuthorizationStatus;
    /** Authorization code represents the status of the transaction */
    code!: AuthorizationCode;
    /** The details of authorization at a line item level. */
    authorizationDetails!: AuthLineItemDetails[];
    /** Array of purse utilization details. */
    purseUtilization!: PurseUsage[];
    /** Maximum amount that will be funded for this transaction to allow for retailer funding options. */
    maxFundingAmount?: AuthorizationMaxFundingAmount | undefined;
    details?: ExceptionDetails | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;

    constructor(data?: IAuthorization) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.authorizationDetails = [];
            this.purseUtilization = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.merchantTransactionId = _data["merchantTransactionId"];
            this.nationsBenefitsTransactionId = _data["nationsBenefitsTransactionId"];
            this.authorizedTransactionAmount = _data["authorizedTransactionAmount"];
            this.status = _data["status"];
            this.code = _data["code"];
            if (Array.isArray(_data["authorizationDetails"])) {
                this.authorizationDetails = [] as any;
                for (let item of _data["authorizationDetails"])
                    this.authorizationDetails!.push(AuthLineItemDetails.fromJS(item));
            }
            if (Array.isArray(_data["purseUtilization"])) {
                this.purseUtilization = [] as any;
                for (let item of _data["purseUtilization"])
                    this.purseUtilization!.push(PurseUsage.fromJS(item));
            }
            this.maxFundingAmount = _data["maxFundingAmount"];
            this.details = _data["details"] ? ExceptionDetails.fromJS(_data["details"]) : <any>undefined;
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): Authorization {
        data = typeof data === 'object' ? data : {};
        let result = new Authorization();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["merchantTransactionId"] = this.merchantTransactionId;
        data["nationsBenefitsTransactionId"] = this.nationsBenefitsTransactionId;
        data["authorizedTransactionAmount"] = this.authorizedTransactionAmount;
        data["status"] = this.status;
        data["code"] = this.code;
        if (Array.isArray(this.authorizationDetails)) {
            data["authorizationDetails"] = [];
            for (let item of this.authorizationDetails)
                data["authorizationDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.purseUtilization)) {
            data["purseUtilization"] = [];
            for (let item of this.purseUtilization)
                data["purseUtilization"].push(item.toJSON());
        }
        data["maxFundingAmount"] = this.maxFundingAmount;
        data["details"] = this.details ? this.details.toJSON() : <any>undefined;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = (<any>this.additionalProperties)[key];
            }
        }
        return data;
    }
}

export interface IAuthorization {
    /** Retailer generated unique identifier for the transaction. */
    merchantTransactionId: string;
    /** The unique identifier for the transaction generated by Nations. */
    nationsBenefitsTransactionId: string;
    /** The total authorized transaction amount (includes tax and refundable deposits). */
    authorizedTransactionAmount: number;
    /** Authorization reason provides detailed information about the transaction status */
    status: AuthorizationStatus;
    /** Authorization code represents the status of the transaction */
    code: AuthorizationCode;
    /** The details of authorization at a line item level. */
    authorizationDetails: AuthLineItemDetails[];
    /** Array of purse utilization details. */
    purseUtilization: PurseUsage[];
    /** Maximum amount that will be funded for this transaction to allow for retailer funding options. */
    maxFundingAmount?: AuthorizationMaxFundingAmount | undefined;
    details?: ExceptionDetails | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;
}

export enum AuthorizationStatus {
    Transaction_fully_approved__more_details_at_line_items = "Transaction fully approved; more details at line items",
    Transaction_partially_approved__more_details_at_line_items = "Transaction partially approved; more details at line items",
    Transaction_entirely_declined_due_to_unauthorized_products_in_the_basket = "Transaction entirely declined due to unauthorized products in the basket",
    Transaction_entirely_declined_due_to_card_reported_lost_or_stolen = "Transaction entirely declined due to card reported lost or stolen",
    Transaction_entirely_declined_due_to_card_not_activated = "Transaction entirely declined due to card not activated",
    Transaction_entirely_declined_due_to_no_funds_in_the_purses = "Transaction entirely declined due to no funds in the purses",
    Transaction_entirely_declined_due_to_other_membership_issues__contact_nations_for_more_details = "Transaction entirely declined due to other membership issues. contact nations for more details",
    Transaction_entirely_declined_due_purchase_at_an_unauthorized_store_location_or_online_retailer_or_country = "Transaction entirely declined due purchase at an unauthorized store location or online retailer or country",
    Transaction_entirely_declined_due_suspected_fraud = "Transaction entirely declined due suspected fraud",
    Transaction_entirely_declined_because_mixed_transactions_are_not_supported_when_maxFundingAmount_is_used = "Transaction entirely declined because mixed transactions are not supported when maxFundingAmount is used",
    Transaction_entirely_declined_because_prior_transaction_id_could_not_be_found = "Transaction entirely declined because prior transaction id could not be found",
    Transaction_could_not_be_processed_due_to_no_items_sent_in_the_transaction = "Transaction could not be processed due to no items sent in the transaction",
    Transaction_could_not_be_processed_because_dependent_transaction_could_not_be_found = "Transaction could not be processed because dependent transaction could not be found",
    Transaction_entirely_declined_due_to_card_not_being_enabled_for_this_transaction = "Transaction entirely declined due to card not being enabled for this transaction",
}

export enum AuthorizationCode {
    _000 = "000",
    _100 = "100",
    _200 = "200",
    _201 = "201",
    _202 = "202",
    _203 = "203",
    _204 = "204",
    _205 = "205",
    _206 = "206",
    _207 = "207",
    _208 = "208",
    _209 = "209",
    _210 = "210",
    _211 = "211",
}

export class AuthLineItemDetails implements IAuthLineItemDetails {
    /** The line item number. */
    lineItemNumber!: number;
    /** The product code as passed in the request for the line item. */
    productCode!: string;
    /** The product code type as passed in the request for the line item. */
    productCodeType!: string;
    /** The authorized transaction amount (does not include tax and refundable deposits) for this line item. */
    authorizedAmountBeforeTax!: number;
    /** The authorized tax for this line item. */
    authorizedTax!: number;
    /** The authorized fee for this line item. */
    authorizedFees!: number;
    /** Summary of the authorization. */
    authResult!: AuthLineItemDetailsAuthResult;
    /** The name of the benefit type authorized for this line item. NA = No Benefit. */
    benefitName!: string;
    /** Authorization code represents the status of the transaction */
    code!: number;
    /** Authorization reason provides detailed information about the transaction status */
    status!: AuthLineItemDetailsStatus;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;

    constructor(data?: IAuthLineItemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.lineItemNumber = _data["lineItemNumber"];
            this.productCode = _data["productCode"];
            this.productCodeType = _data["productCodeType"];
            this.authorizedAmountBeforeTax = _data["authorizedAmountBeforeTax"];
            this.authorizedTax = _data["authorizedTax"];
            this.authorizedFees = _data["authorizedFees"];
            this.authResult = _data["authResult"];
            this.benefitName = _data["benefitName"];
            this.code = _data["code"];
            this.status = _data["status"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): AuthLineItemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new AuthLineItemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["lineItemNumber"] = this.lineItemNumber;
        data["productCode"] = this.productCode;
        data["productCodeType"] = this.productCodeType;
        data["authorizedAmountBeforeTax"] = this.authorizedAmountBeforeTax;
        data["authorizedTax"] = this.authorizedTax;
        data["authorizedFees"] = this.authorizedFees;
        data["authResult"] = this.authResult;
        data["benefitName"] = this.benefitName;
        data["code"] = this.code;
        data["status"] = this.status;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = (<any>this.additionalProperties)[key];
            }
        }
        return data;
    }
}

export interface IAuthLineItemDetails {
    /** The line item number. */
    lineItemNumber: number;
    /** The product code as passed in the request for the line item. */
    productCode: string;
    /** The product code type as passed in the request for the line item. */
    productCodeType: string;
    /** The authorized transaction amount (does not include tax and refundable deposits) for this line item. */
    authorizedAmountBeforeTax: number;
    /** The authorized tax for this line item. */
    authorizedTax: number;
    /** The authorized fee for this line item. */
    authorizedFees: number;
    /** Summary of the authorization. */
    authResult: AuthLineItemDetailsAuthResult;
    /** The name of the benefit type authorized for this line item. NA = No Benefit. */
    benefitName: string;
    /** Authorization code represents the status of the transaction */
    code: number;
    /** Authorization reason provides detailed information about the transaction status */
    status: AuthLineItemDetailsStatus;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;
}

export enum AuthLineItemDetailsAuthResult {
    APPROVED = "APPROVED",
    DECLINED = "DECLINED",
    APPROVED_PARTIAL = "APPROVED_PARTIAL",
}

export enum AuthLineItemDetailsStatus {
    Approved__and_sufficient_funds_in_purse = "Approved, and sufficient funds in purse",
    Approved_product__purchase_exceeds_maxFundingAmount = "Approved product, purchase exceeds maxFundingAmount",
    Approved_product__insufficient_purse_funds = "Approved product, insufficient purse funds",
    Exceeded_item_limit_for_specific_product__but_some_quantity_approved = "Exceeded item limit for specific product, but some quantity approved",
    Exceeded_dollar_limit_for_specific_product__but_partial_dollar_amount_approved = "Exceeded dollar limit for specific product, but partial dollar amount approved",
    Approved_product_but_no_funds_in_purse = "Approved product but no funds in purse",
    Attempted_to_purchase_a_nonAllowable_item__not_on_APL_ = "Attempted to purchase a non-allowable item (not on APL)",
    Exceeded_item_limit_for_specific_product_or_category = "Exceeded item limit for specific product or category",
    Exceeded_dollar_limit_for_specific_product_or_category = "Exceeded dollar limit for specific product or category",
    Unable_to_process_this_item_due_to_format_issue = "Unable to process this item due to format issue",
    Custom_name_value_pair_was_not_recognized_causing_item_to_not_be_processed = "Custom name value pair was not recognized causing item to not be processed",
    Return_approved__funds_will_be_restored_to_purse = "Return approved, funds will be restored to purse",
    Approved_product__return_exceeds_maxFundingAmount = "Approved product, return exceeds maxFundingAmount",
    Return_exceeds_original_purchase_quantity__but_partial_return_approved = "Return exceeds original purchase quantity, but partial return approved",
    Return_exceeds_original_purchase_amount__but_partial_return_approved = "Return exceeds original purchase amount, but partial return approved",
    Return_attempted_for_nonAllowable_item__not_on_APL_ = "Return attempted for non-allowable item (not on APL)",
    Return_would_exceed_purse_dollar_limit = "Return would exceed purse dollar limit",
    No_record_of_such_an_item_being_purchased_by_the_member = "No record of such an item being purchased by the member",
    Return_attempted_after_allowed_period__180_days_after_purchase_ = "Return attempted after allowed period (180 days after purchase)",
}

export class PurseUsage implements IPurseUsage {
    /** Name of the purse. */
    purseName?: string | undefined;
    /** Amount used from the purse. */
    amountUsed?: number | undefined;
    /** Remaining balance in the purse. */
    remainingBalance?: number | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;

    constructor(data?: IPurseUsage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.purseName = _data["purseName"];
            this.amountUsed = _data["amountUsed"];
            this.remainingBalance = _data["remainingBalance"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): PurseUsage {
        data = typeof data === 'object' ? data : {};
        let result = new PurseUsage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["purseName"] = this.purseName;
        data["amountUsed"] = this.amountUsed;
        data["remainingBalance"] = this.remainingBalance;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = (<any>this.additionalProperties)[key];
            }
        }
        return data;
    }
}

export interface IPurseUsage {
    /** Name of the purse. */
    purseName?: string | undefined;
    /** Amount used from the purse. */
    amountUsed?: number | undefined;
    /** Remaining balance in the purse. */
    remainingBalance?: number | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;
}

export enum AuthorizationMaxFundingAmount {
    USD = "USD",
    CAD = "CAD",
}

export class AnalyzeRequest implements IAnalyzeRequest {
    member!: Member;
    merchant!: Merchant;
    transaction!: Transaction;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;

    constructor(data?: IAnalyzeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.member = new Member();
            this.merchant = new Merchant();
            this.transaction = new Transaction();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.member = _data["member"] ? Member.fromJS(_data["member"]) : new Member();
            this.merchant = _data["merchant"] ? Merchant.fromJS(_data["merchant"]) : new Merchant();
            this.transaction = _data["transaction"] ? Transaction.fromJS(_data["transaction"]) : new Transaction();
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): AnalyzeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AnalyzeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["member"] = this.member ? this.member.toJSON() : <any>undefined;
        data["merchant"] = this.merchant ? this.merchant.toJSON() : <any>undefined;
        data["transaction"] = this.transaction ? this.transaction.toJSON() : <any>undefined;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = (<any>this.additionalProperties)[key];
            }
        }
        return data;
    }
}

export interface IAnalyzeRequest {
    member: Member;
    merchant: Merchant;
    transaction: Transaction;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;
}

export class Transaction implements ITransaction {
    /** Merchant generated unique identifier for the transaction. */
    merchantTransactionId!: string;
    /** ISO 8601; The local date and time when the transaction was made, represented in local time and expressed with its UTC offset (e.g., "2023-07-19T13:20:30+01:00"). */
    transactionLocalDateTime!: string;
    /** The currency code for the transaction. */
    transactionCurrencyCode!: TransactionCurrencyCode;
    lineItems!: LineItem[];
    /** Maximum amount that will be funded for this transaction to allow for retailer funding options. */
    maxFundingAmount?: TransactionMaxFundingAmount | undefined;
    /** The NationsBenefits transaction ID that was used in a related transaction, e.g. eCommerce initial order capture. */
    parentNationsBenefitsTransactionId?: string | undefined;
    /** The name of the retailer at which the transaction was executed. */
    transactionRetailer?: string | undefined;
    /** The the address of the retailer at which the trasnaction was executed. */
    transactionRetailerLocation?: string | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;

    constructor(data?: ITransaction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.lineItems = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.merchantTransactionId = _data["merchantTransactionId"];
            this.transactionLocalDateTime = _data["transactionLocalDateTime"];
            this.transactionCurrencyCode = _data["transactionCurrencyCode"];
            if (Array.isArray(_data["lineItems"])) {
                this.lineItems = [] as any;
                for (let item of _data["lineItems"])
                    this.lineItems!.push(LineItem.fromJS(item));
            }
            this.maxFundingAmount = _data["maxFundingAmount"];
            this.parentNationsBenefitsTransactionId = _data["parentNationsBenefitsTransactionId"];
            this.transactionRetailer = _data["transactionRetailer"];
            this.transactionRetailerLocation = _data["transactionRetailerLocation"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): Transaction {
        data = typeof data === 'object' ? data : {};
        let result = new Transaction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["merchantTransactionId"] = this.merchantTransactionId;
        data["transactionLocalDateTime"] = this.transactionLocalDateTime;
        data["transactionCurrencyCode"] = this.transactionCurrencyCode;
        if (Array.isArray(this.lineItems)) {
            data["lineItems"] = [];
            for (let item of this.lineItems)
                data["lineItems"].push(item.toJSON());
        }
        data["maxFundingAmount"] = this.maxFundingAmount;
        data["parentNationsBenefitsTransactionId"] = this.parentNationsBenefitsTransactionId;
        data["transactionRetailer"] = this.transactionRetailer;
        data["transactionRetailerLocation"] = this.transactionRetailerLocation;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = (<any>this.additionalProperties)[key];
            }
        }
        return data;
    }
}

export interface ITransaction {
    /** Merchant generated unique identifier for the transaction. */
    merchantTransactionId: string;
    /** ISO 8601; The local date and time when the transaction was made, represented in local time and expressed with its UTC offset (e.g., "2023-07-19T13:20:30+01:00"). */
    transactionLocalDateTime: string;
    /** The currency code for the transaction. */
    transactionCurrencyCode: TransactionCurrencyCode;
    lineItems: LineItem[];
    /** Maximum amount that will be funded for this transaction to allow for retailer funding options. */
    maxFundingAmount?: TransactionMaxFundingAmount | undefined;
    /** The NationsBenefits transaction ID that was used in a related transaction, e.g. eCommerce initial order capture. */
    parentNationsBenefitsTransactionId?: string | undefined;
    /** The name of the retailer at which the transaction was executed. */
    transactionRetailer?: string | undefined;
    /** The the address of the retailer at which the trasnaction was executed. */
    transactionRetailerLocation?: string | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;
}

export enum TransactionCurrencyCode {
    USD = "USD",
    CAD = "CAD",
}

export class LineItem implements ILineItem {
    /** The line item number. */
    lineItemNumber!: number;
    /** The type of the product code. */
    productCodeType!: LineItemProductCodeType;
    /** The unique product identifier. If the productCodeType = 'CAT_SUBCAT', the code would be a combination of item product category code and sub category code delimited by '|' */
    productCode!: string;
    /** The unit price of the product. This number is positive for sale and negative for a return. */
    unitPrice!: number;
    /** The quantity of the product. If negative value is passed, it will be interpreted as positive. */
    quantity!: number;
    /** The unit of weight or volume for the product. Use 'COUNT' for countable quantities. */
    units!: LineItemUnits;
    /** This array contains tax details for the line item. */
    taxes?: TaxDetails[] | undefined;
    /** This object contains fees such as CRV and Bottle refund details for the line item. */
    fees?: FeesDetails[] | undefined;
    /** This object contains key value pairs provided by retailer to perform custom actions in the request */
    optionalFields?: OptionalFields[] | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;

    constructor(data?: ILineItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.lineItemNumber = _data["lineItemNumber"];
            this.productCodeType = _data["productCodeType"];
            this.productCode = _data["productCode"];
            this.unitPrice = _data["unitPrice"];
            this.quantity = _data["quantity"];
            this.units = _data["units"];
            if (Array.isArray(_data["taxes"])) {
                this.taxes = [] as any;
                for (let item of _data["taxes"])
                    this.taxes!.push(TaxDetails.fromJS(item));
            }
            if (Array.isArray(_data["fees"])) {
                this.fees = [] as any;
                for (let item of _data["fees"])
                    this.fees!.push(FeesDetails.fromJS(item));
            }
            if (Array.isArray(_data["optionalFields"])) {
                this.optionalFields = [] as any;
                for (let item of _data["optionalFields"])
                    this.optionalFields!.push(OptionalFields.fromJS(item));
            }
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): LineItem {
        data = typeof data === 'object' ? data : {};
        let result = new LineItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["lineItemNumber"] = this.lineItemNumber;
        data["productCodeType"] = this.productCodeType;
        data["productCode"] = this.productCode;
        data["unitPrice"] = this.unitPrice;
        data["quantity"] = this.quantity;
        data["units"] = this.units;
        if (Array.isArray(this.taxes)) {
            data["taxes"] = [];
            for (let item of this.taxes)
                data["taxes"].push(item.toJSON());
        }
        if (Array.isArray(this.fees)) {
            data["fees"] = [];
            for (let item of this.fees)
                data["fees"].push(item.toJSON());
        }
        if (Array.isArray(this.optionalFields)) {
            data["optionalFields"] = [];
            for (let item of this.optionalFields)
                data["optionalFields"].push(item.toJSON());
        }
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = (<any>this.additionalProperties)[key];
            }
        }
        return data;
    }
}

export interface ILineItem {
    /** The line item number. */
    lineItemNumber: number;
    /** The type of the product code. */
    productCodeType: LineItemProductCodeType;
    /** The unique product identifier. If the productCodeType = 'CAT_SUBCAT', the code would be a combination of item product category code and sub category code delimited by '|' */
    productCode: string;
    /** The unit price of the product. This number is positive for sale and negative for a return. */
    unitPrice: number;
    /** The quantity of the product. If negative value is passed, it will be interpreted as positive. */
    quantity: number;
    /** The unit of weight or volume for the product. Use 'COUNT' for countable quantities. */
    units: LineItemUnits;
    /** This array contains tax details for the line item. */
    taxes?: TaxDetails[] | undefined;
    /** This object contains fees such as CRV and Bottle refund details for the line item. */
    fees?: FeesDetails[] | undefined;
    /** This object contains key value pairs provided by retailer to perform custom actions in the request */
    optionalFields?: OptionalFields[] | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;
}

export enum LineItemProductCodeType {
    UPC = "UPC",
    PLU = "PLU",
    GTIN = "GTIN",
    CAT_SUBCAT = "CAT_SUBCAT",
    ICD10 = "ICD10",
    OTHER = "OTHER",
}

export enum LineItemUnits {
    COUNT = "COUNT",
    GM = "GM",
    OZ = "OZ",
    LB = "LB",
    KG = "KG",
    GAL = "GAL",
    FLOZ = "FLOZ",
    L = "L",
    ML = "ML",
}

export class TaxDetails implements ITaxDetails {
    /** Type of tax that is associated with the item.  Examples include SALES, VAT, GST, EXCISE, IMPORT_DUTY, LUXURY, OTHER */
    taxType!: string;
    /** Amount of the specific tax. */
    value!: number;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;

    constructor(data?: ITaxDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.taxType = _data["taxType"];
            this.value = _data["value"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): TaxDetails {
        data = typeof data === 'object' ? data : {};
        let result = new TaxDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["taxType"] = this.taxType;
        data["value"] = this.value;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = (<any>this.additionalProperties)[key];
            }
        }
        return data;
    }
}

export interface ITaxDetails {
    /** Type of tax that is associated with the item.  Examples include SALES, VAT, GST, EXCISE, IMPORT_DUTY, LUXURY, OTHER */
    taxType: string;
    /** Amount of the specific tax. */
    value: number;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;
}

export class FeesDetails implements IFeesDetails {
    /** Type of refundable deposit or other fees associated with an item.  Examples include DEPOSIT, TARE, COST_PLUS, OTHER */
    feeType!: string;
    /** Amount of the specific fees. */
    value!: number;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;

    constructor(data?: IFeesDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.feeType = _data["feeType"];
            this.value = _data["value"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): FeesDetails {
        data = typeof data === 'object' ? data : {};
        let result = new FeesDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["feeType"] = this.feeType;
        data["value"] = this.value;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = (<any>this.additionalProperties)[key];
            }
        }
        return data;
    }
}

export interface IFeesDetails {
    /** Type of refundable deposit or other fees associated with an item.  Examples include DEPOSIT, TARE, COST_PLUS, OTHER */
    feeType: string;
    /** Amount of the specific fees. */
    value: number;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;
}

export class OptionalFields implements IOptionalFields {
    /** Retailer specific option to provide to BAS generally for custom requests */
    name!: any;
    /** Value associated with retailer specific option */
    value!: any;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;

    constructor(data?: IOptionalFields) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.value = _data["value"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): OptionalFields {
        data = typeof data === 'object' ? data : {};
        let result = new OptionalFields();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["value"] = this.value;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = (<any>this.additionalProperties)[key];
            }
        }
        return data;
    }
}

export interface IOptionalFields {
    /** Retailer specific option to provide to BAS generally for custom requests */
    name: any;
    /** Value associated with retailer specific option */
    value: any;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;
}

export enum TransactionMaxFundingAmount {
    USD = "USD",
    CAD = "CAD",
}

export class RedeemResponse implements IRedeemResponse {
    response!: Response7;
    nbInternalTrace!: NationsInternalTrace;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;

    constructor(data?: IRedeemResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.response = new Response7();
            this.nbInternalTrace = new NationsInternalTrace();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.response = _data["response"] ? Response7.fromJS(_data["response"]) : new Response7();
            this.nbInternalTrace = _data["nbInternalTrace"] ? NationsInternalTrace.fromJS(_data["nbInternalTrace"]) : new NationsInternalTrace();
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): RedeemResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RedeemResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["response"] = this.response ? this.response.toJSON() : <any>undefined;
        data["nbInternalTrace"] = this.nbInternalTrace ? this.nbInternalTrace.toJSON() : <any>undefined;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = (<any>this.additionalProperties)[key];
            }
        }
        return data;
    }
}

export interface IRedeemResponse {
    response: Response7;
    nbInternalTrace: NationsInternalTrace;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;
}

export class Response7 implements IResponse7 {
    /** The unique identifier for the transaction that was generated by NationsBenefits in response to the Analyze call. */
    nationsBenefitsTransactionId?: string | undefined;
    /** The status of the redemption. */
    status?: Response7Status | undefined;
    /** The code associated with the redemption status. */
    code?: Response7Code | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;

    constructor(data?: IResponse7) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.nationsBenefitsTransactionId = _data["nationsBenefitsTransactionId"];
            this.status = _data["status"];
            this.code = _data["code"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): Response7 {
        data = typeof data === 'object' ? data : {};
        let result = new Response7();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["nationsBenefitsTransactionId"] = this.nationsBenefitsTransactionId;
        data["status"] = this.status;
        data["code"] = this.code;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = (<any>this.additionalProperties)[key];
            }
        }
        return data;
    }
}

export interface IResponse7 {
    /** The unique identifier for the transaction that was generated by NationsBenefits in response to the Analyze call. */
    nationsBenefitsTransactionId?: string | undefined;
    /** The status of the redemption. */
    status?: Response7Status | undefined;
    /** The code associated with the redemption status. */
    code?: Response7Code | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;
}

export enum Response7Status {
    REDEMPTION_SUCCESSFUL = "REDEMPTION_SUCCESSFUL",
    REDEMPTION_FAILED_INCORRECT_AMOUNT_REDEEMED = "REDEMPTION_FAILED_INCORRECT_AMOUNT_REDEEMED",
    REDEMPTION_FAILED_DUPLICATE_REDEMPTION_REQUEST = "REDEMPTION_FAILED_DUPLICATE_REDEMPTION_REQUEST",
    REDEMPTION_FAILED_INVALID_NB_TRANSACTION_ID = "REDEMPTION_FAILED_INVALID_NB_TRANSACTION_ID",
    REDEMPTION_FAILED_OTHER = "REDEMPTION_FAILED_OTHER",
}

export enum Response7Code {
    _000 = "000",
    _201 = "201",
    _202 = "202",
    _203 = "203",
    _204 = "204",
}

export class RedeemRequest implements IRedeemRequest {
    /** The unique identifier for the transaction that was generated by NationsBenefits in response to the Analyze call. */
    nationsBenefitsTransactionId!: string;
    /** Type of the redemption transaction. Each type corresponds to different transaction actions internally: - "000": Default type if not provided, often representing generic handshake representing authorized transaction amount redemption from the Issuer (happy-path). - "100": For voiding a previously authorized request/transaction. - "200": For reversing a previously authorized request/transaction. - "300": For voiding an auth, used in the scenarios where the POS/merchant receives an incorrect amount ($) from the Issuer. Defaults to '000' if not provided. */
    redeemType?: RedeemRequestRedeemType | undefined;
    /** The redeemed amount. */
    redeemedAmount!: number;
    /** Optional data field for the merchant to send additional information. */
    merchantDiscretionaryData?: string | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;

    constructor(data?: IRedeemRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.nationsBenefitsTransactionId = _data["nationsBenefitsTransactionId"];
            this.redeemType = _data["redeemType"];
            this.redeemedAmount = _data["redeemedAmount"];
            this.merchantDiscretionaryData = _data["merchantDiscretionaryData"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): RedeemRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RedeemRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["nationsBenefitsTransactionId"] = this.nationsBenefitsTransactionId;
        data["redeemType"] = this.redeemType;
        data["redeemedAmount"] = this.redeemedAmount;
        data["merchantDiscretionaryData"] = this.merchantDiscretionaryData;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = (<any>this.additionalProperties)[key];
            }
        }
        return data;
    }
}

export interface IRedeemRequest {
    /** The unique identifier for the transaction that was generated by NationsBenefits in response to the Analyze call. */
    nationsBenefitsTransactionId: string;
    /** Type of the redemption transaction. Each type corresponds to different transaction actions internally: - "000": Default type if not provided, often representing generic handshake representing authorized transaction amount redemption from the Issuer (happy-path). - "100": For voiding a previously authorized request/transaction. - "200": For reversing a previously authorized request/transaction. - "300": For voiding an auth, used in the scenarios where the POS/merchant receives an incorrect amount ($) from the Issuer. Defaults to '000' if not provided. */
    redeemType?: RedeemRequestRedeemType | undefined;
    /** The redeemed amount. */
    redeemedAmount: number;
    /** Optional data field for the merchant to send additional information. */
    merchantDiscretionaryData?: string | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;
}

export enum RedeemRequestRedeemType {
    _000 = "000",
    _100 = "100",
    _200 = "200",
    _300 = "300",
}

export class VoidResponse implements IVoidResponse {
    response!: Response8;
    /** Optional data field for the merchant to send additional information. */
    merchantDiscretionaryData?: string | undefined;
    nbInternalTrace!: NationsInternalTrace;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;

    constructor(data?: IVoidResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.response = new Response8();
            this.nbInternalTrace = new NationsInternalTrace();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.response = _data["response"] ? Response8.fromJS(_data["response"]) : new Response8();
            this.merchantDiscretionaryData = _data["merchantDiscretionaryData"];
            this.nbInternalTrace = _data["nbInternalTrace"] ? NationsInternalTrace.fromJS(_data["nbInternalTrace"]) : new NationsInternalTrace();
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): VoidResponse {
        data = typeof data === 'object' ? data : {};
        let result = new VoidResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["response"] = this.response ? this.response.toJSON() : <any>undefined;
        data["merchantDiscretionaryData"] = this.merchantDiscretionaryData;
        data["nbInternalTrace"] = this.nbInternalTrace ? this.nbInternalTrace.toJSON() : <any>undefined;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = (<any>this.additionalProperties)[key];
            }
        }
        return data;
    }
}

export interface IVoidResponse {
    response: Response8;
    /** Optional data field for the merchant to send additional information. */
    merchantDiscretionaryData?: string | undefined;
    nbInternalTrace: NationsInternalTrace;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;
}

export class Response8 implements IResponse8 {
    /** The unique identifier for the transaction that was generated by NationsBenefits in response to the Analyze call. */
    nationsBenefitsTransactionId?: string | undefined;
    /** The status of the void. */
    status?: Response8Status | undefined;
    /** The code associated with the void status. */
    code?: Response8Code | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;

    constructor(data?: IResponse8) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.nationsBenefitsTransactionId = _data["nationsBenefitsTransactionId"];
            this.status = _data["status"];
            this.code = _data["code"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): Response8 {
        data = typeof data === 'object' ? data : {};
        let result = new Response8();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["nationsBenefitsTransactionId"] = this.nationsBenefitsTransactionId;
        data["status"] = this.status;
        data["code"] = this.code;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = (<any>this.additionalProperties)[key];
            }
        }
        return data;
    }
}

export interface IResponse8 {
    /** The unique identifier for the transaction that was generated by NationsBenefits in response to the Analyze call. */
    nationsBenefitsTransactionId?: string | undefined;
    /** The status of the void. */
    status?: Response8Status | undefined;
    /** The code associated with the void status. */
    code?: Response8Code | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;
}

export enum Response8Status {
    VOID_SUCCESSFUL = "VOID_SUCCESSFUL",
    VOID_FAILED_UNRECOGNIZED_NB_ID = "VOID_FAILED_UNRECOGNIZED_NB_ID",
    VOID_FAILED_DUPLICATE_REQUEST = "VOID_FAILED_DUPLICATE_REQUEST",
    VOID_FAILED_OTHER = "VOID_FAILED_OTHER",
}

export enum Response8Code {
    _000 = "000",
    _201 = "201",
    _202 = "202",
    _203 = "203",
}

export class VoidRequest implements IVoidRequest {
    /** The unique identifier for the transaction that was generated by BAS in response to the Analyze call. */
    nationsBenefitsTransactionId!: string;
    /** Optional data field for the merchant to send additional information. */
    merchantDiscretionaryData?: string | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;

    constructor(data?: IVoidRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.nationsBenefitsTransactionId = _data["nationsBenefitsTransactionId"];
            this.merchantDiscretionaryData = _data["merchantDiscretionaryData"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): VoidRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VoidRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["nationsBenefitsTransactionId"] = this.nationsBenefitsTransactionId;
        data["merchantDiscretionaryData"] = this.merchantDiscretionaryData;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = (<any>this.additionalProperties)[key];
            }
        }
        return data;
    }
}

export interface IVoidRequest {
    /** The unique identifier for the transaction that was generated by BAS in response to the Analyze call. */
    nationsBenefitsTransactionId: string;
    /** Optional data field for the merchant to send additional information. */
    merchantDiscretionaryData?: string | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;
}

export class ReversalResponse implements IReversalResponse {
    response!: Response9;
    /** Optional data field for the merchant to send additional information. */
    merchantDiscretionaryData?: string | undefined;
    nbInternalTrace!: NationsInternalTrace;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;

    constructor(data?: IReversalResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.response = new Response9();
            this.nbInternalTrace = new NationsInternalTrace();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.response = _data["response"] ? Response9.fromJS(_data["response"]) : new Response9();
            this.merchantDiscretionaryData = _data["merchantDiscretionaryData"];
            this.nbInternalTrace = _data["nbInternalTrace"] ? NationsInternalTrace.fromJS(_data["nbInternalTrace"]) : new NationsInternalTrace();
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): ReversalResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ReversalResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["response"] = this.response ? this.response.toJSON() : <any>undefined;
        data["merchantDiscretionaryData"] = this.merchantDiscretionaryData;
        data["nbInternalTrace"] = this.nbInternalTrace ? this.nbInternalTrace.toJSON() : <any>undefined;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = (<any>this.additionalProperties)[key];
            }
        }
        return data;
    }
}

export interface IReversalResponse {
    response: Response9;
    /** Optional data field for the merchant to send additional information. */
    merchantDiscretionaryData?: string | undefined;
    nbInternalTrace: NationsInternalTrace;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;
}

export class Response9 implements IResponse9 {
    /** The unique identifier for the transaction that was generated by NationsBenefits in response to the Analyze call. */
    nationsBenefitsTransactionId?: string | undefined;
    /** The status of the reversal. */
    status?: Response9Status | undefined;
    /** The code associated with the reversal status. */
    code?: Response9Code | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;

    constructor(data?: IResponse9) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.nationsBenefitsTransactionId = _data["nationsBenefitsTransactionId"];
            this.status = _data["status"];
            this.code = _data["code"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): Response9 {
        data = typeof data === 'object' ? data : {};
        let result = new Response9();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["nationsBenefitsTransactionId"] = this.nationsBenefitsTransactionId;
        data["status"] = this.status;
        data["code"] = this.code;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = (<any>this.additionalProperties)[key];
            }
        }
        return data;
    }
}

export interface IResponse9 {
    /** The unique identifier for the transaction that was generated by NationsBenefits in response to the Analyze call. */
    nationsBenefitsTransactionId?: string | undefined;
    /** The status of the reversal. */
    status?: Response9Status | undefined;
    /** The code associated with the reversal status. */
    code?: Response9Code | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;
}

export enum Response9Status {
    REVERSAL_SUCCESSFUL = "REVERSAL_SUCCESSFUL",
    REVERSAL_FAILED_UNRECOGNIZED_NB_ID = "REVERSAL_FAILED_UNRECOGNIZED_NB_ID",
    REVERSAL_FAILED_DUPLICATE_REQUEST = "REVERSAL_FAILED_DUPLICATE_REQUEST",
    REVERSAL_FAILED_OTHER = "REVERSAL_FAILED_OTHER",
}

export enum Response9Code {
    _000 = "000",
    _201 = "201",
    _202 = "202",
    _203 = "203",
}

export class ReversalRequest implements IReversalRequest {
    /** The unique identifier for the transaction that was generated by BAS in response to the Analyze call.  Note that this value will not be required if a combination of the entityId, merchantTransactionId, and transactionLocalDateTime are all provided. */
    nationsBenefitsTransactionId!: string;
    /** Optional data field for the merchant to send additional information. */
    merchantDiscretionaryData?: string | undefined;
    /** The unique identifier for the parent entity of the retailer or the processing entity. */
    entityId?: string | undefined;
    /** The unique identifier for the store of the retailer or the processing entity. */
    storeId?: string | undefined;
    /** The unique identifier for the termina entity of the retailer or the processing entity. */
    terminalId?: string | undefined;
    /** Merchant generated unique identifier for the transaction. */
    merchantTransactionId?: string | undefined;
    /** ISO 8601; The local date and time when the transaction was made, represented in local time and expressed with its UTC offset (e.g., "2023-07-19T13:20:30+01:00"). */
    transactionLocalDateTime?: string | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;

    constructor(data?: IReversalRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.nationsBenefitsTransactionId = _data["nationsBenefitsTransactionId"];
            this.merchantDiscretionaryData = _data["merchantDiscretionaryData"];
            this.entityId = _data["entityId"];
            this.storeId = _data["storeId"];
            this.terminalId = _data["terminalId"];
            this.merchantTransactionId = _data["merchantTransactionId"];
            this.transactionLocalDateTime = _data["transactionLocalDateTime"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): ReversalRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ReversalRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["nationsBenefitsTransactionId"] = this.nationsBenefitsTransactionId;
        data["merchantDiscretionaryData"] = this.merchantDiscretionaryData;
        data["entityId"] = this.entityId;
        data["storeId"] = this.storeId;
        data["terminalId"] = this.terminalId;
        data["merchantTransactionId"] = this.merchantTransactionId;
        data["transactionLocalDateTime"] = this.transactionLocalDateTime;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = (<any>this.additionalProperties)[key];
            }
        }
        return data;
    }
}

export interface IReversalRequest {
    /** The unique identifier for the transaction that was generated by BAS in response to the Analyze call.  Note that this value will not be required if a combination of the entityId, merchantTransactionId, and transactionLocalDateTime are all provided. */
    nationsBenefitsTransactionId: string;
    /** Optional data field for the merchant to send additional information. */
    merchantDiscretionaryData?: string | undefined;
    /** The unique identifier for the parent entity of the retailer or the processing entity. */
    entityId?: string | undefined;
    /** The unique identifier for the store of the retailer or the processing entity. */
    storeId?: string | undefined;
    /** The unique identifier for the termina entity of the retailer or the processing entity. */
    terminalId?: string | undefined;
    /** Merchant generated unique identifier for the transaction. */
    merchantTransactionId?: string | undefined;
    /** ISO 8601; The local date and time when the transaction was made, represented in local time and expressed with its UTC offset (e.g., "2023-07-19T13:20:30+01:00"). */
    transactionLocalDateTime?: string | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;

    [key: string]: any;
}

export class NegativePriceProductMovementDto implements INegativePriceProductMovementDto {
    upc?: string | undefined;
    datetime?: Date | undefined;
    description?: string | undefined;
    transactionNumber?: string | undefined;
    qty?: number;
    sales?: number;
    storeId?: number;
    storeName?: string | undefined;

    constructor(data?: INegativePriceProductMovementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.upc = _data["upc"];
            this.datetime = _data["datetime"] ? new Date(_data["datetime"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.transactionNumber = _data["transactionNumber"];
            this.qty = _data["qty"];
            this.sales = _data["sales"];
            this.storeId = _data["storeId"];
            this.storeName = _data["storeName"];
        }
    }

    static fromJS(data: any): NegativePriceProductMovementDto {
        data = typeof data === 'object' ? data : {};
        let result = new NegativePriceProductMovementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["upc"] = this.upc;
        data["datetime"] = this.datetime ? this.datetime.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["transactionNumber"] = this.transactionNumber;
        data["qty"] = this.qty;
        data["sales"] = this.sales;
        data["storeId"] = this.storeId;
        data["storeName"] = this.storeName;
        return data;
    }
}

export interface INegativePriceProductMovementDto {
    upc?: string | undefined;
    datetime?: Date | undefined;
    description?: string | undefined;
    transactionNumber?: string | undefined;
    qty?: number;
    sales?: number;
    storeId?: number;
    storeName?: string | undefined;
}

export class TransactionResponse implements ITransactionResponse {
    transation?: TransationTan | undefined;
    amount?: string | undefined;
    transationStatue?: string | undefined;

    constructor(data?: ITransactionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transation = _data["transation"] ? TransationTan.fromJS(_data["transation"]) : <any>undefined;
            this.amount = _data["amount"];
            this.transationStatue = _data["transationStatue"];
        }
    }

    static fromJS(data: any): TransactionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transation"] = this.transation ? this.transation.toJSON() : <any>undefined;
        data["amount"] = this.amount;
        data["transationStatue"] = this.transationStatue;
        return data;
    }
}

export interface ITransactionResponse {
    transation?: TransationTan | undefined;
    amount?: string | undefined;
    transationStatue?: string | undefined;
}

export class TransationTan implements ITransationTan {
    total?: number;
    tax?: number;
    subtotal?: number;
    cardtype?: string | undefined;
    items?: TransationItem[] | undefined;

    constructor(data?: ITransationTan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"];
            this.tax = _data["tax"];
            this.subtotal = _data["subtotal"];
            this.cardtype = _data["cardtype"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TransationItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TransationTan {
        data = typeof data === 'object' ? data : {};
        let result = new TransationTan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        data["tax"] = this.tax;
        data["subtotal"] = this.subtotal;
        data["cardtype"] = this.cardtype;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITransationTan {
    total?: number;
    tax?: number;
    subtotal?: number;
    cardtype?: string | undefined;
    items?: TransationItem[] | undefined;
}

export class TransationItem implements ITransationItem {
    description?: string | undefined;
    qty?: number;
    price?: number;

    constructor(data?: ITransationItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.qty = _data["qty"];
            this.price = _data["price"];
        }
    }

    static fromJS(data: any): TransationItem {
        data = typeof data === 'object' ? data : {};
        let result = new TransationItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["qty"] = this.qty;
        data["price"] = this.price;
        return data;
    }
}

export interface ITransationItem {
    description?: string | undefined;
    qty?: number;
    price?: number;
}

export class ValidationProblemDetails implements IValidationProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    errors?: { [key: string]: string[]; } | undefined;

    [key: string]: any;

    constructor(data?: IValidationProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
        }
    }

    static fromJS(data: any): ValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = (<any>this.errors)[key];
            }
        }
        return data;
    }
}

export interface IValidationProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    errors?: { [key: string]: string[]; } | undefined;

    [key: string]: any;
}

export class UserPayment implements IUserPayment {
    cardNumber?: string | undefined;
    pin?: string | undefined;
    cardName?: string | undefined;
    cardDate?: Date;
    cvc?: string | undefined;
    zip?: string | undefined;

    constructor(data?: IUserPayment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cardNumber = _data["cardNumber"];
            this.pin = _data["pin"];
            this.cardName = _data["cardName"];
            this.cardDate = _data["cardDate"] ? new Date(_data["cardDate"].toString()) : <any>undefined;
            this.cvc = _data["cvc"];
            this.zip = _data["zip"];
        }
    }

    static fromJS(data: any): UserPayment {
        data = typeof data === 'object' ? data : {};
        let result = new UserPayment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cardNumber"] = this.cardNumber;
        data["pin"] = this.pin;
        data["cardName"] = this.cardName;
        data["cardDate"] = this.cardDate ? this.cardDate.toISOString() : <any>undefined;
        data["cvc"] = this.cvc;
        data["zip"] = this.zip;
        return data;
    }
}

export interface IUserPayment {
    cardNumber?: string | undefined;
    pin?: string | undefined;
    cardName?: string | undefined;
    cardDate?: Date;
    cvc?: string | undefined;
    zip?: string | undefined;
}

/** 登录后返回数据 */
export class CustomerResponse implements ICustomerResponse {
    user!: UserItem;
    token?: RegToken | undefined;

    constructor(data?: ICustomerResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new UserItem();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? UserItem.fromJS(_data["user"]) : new UserItem();
            this.token = _data["token"] ? RegToken.fromJS(_data["token"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomerResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["token"] = this.token ? this.token.toJSON() : <any>undefined;
        return data;
    }
}

/** 登录后返回数据 */
export interface ICustomerResponse {
    user: UserItem;
    token?: RegToken | undefined;
}

/** 登录后用户数据 */
export class UserItem implements IUserItem {
    id?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    address?: string | undefined;
    city?: string | undefined;
    birthday?: Date | undefined;
    email?: string | undefined;
    zipCode?: string | undefined;
    storeName?: string | undefined;
    cashRegisterID?: string | undefined;
    phonenumber?: string | undefined;
    defaultTime?: string | undefined;
    pointBalance?: number | undefined;
    greetingMessage?: string | undefined;
    logoLink?: string | undefined;

    constructor(data?: IUserItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.address = _data["address"];
            this.city = _data["city"];
            this.birthday = _data["birthday"] ? new Date(_data["birthday"].toString()) : <any>undefined;
            this.email = _data["email"];
            this.zipCode = _data["zipCode"];
            this.storeName = _data["storeName"];
            this.cashRegisterID = _data["cashRegisterID"];
            this.phonenumber = _data["phonenumber"];
            this.defaultTime = _data["defaultTime"];
            this.pointBalance = _data["pointBalance"];
            this.greetingMessage = _data["greetingMessage"];
            this.logoLink = _data["logoLink"];
        }
    }

    static fromJS(data: any): UserItem {
        data = typeof data === 'object' ? data : {};
        let result = new UserItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["address"] = this.address;
        data["city"] = this.city;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["email"] = this.email;
        data["zipCode"] = this.zipCode;
        data["storeName"] = this.storeName;
        data["cashRegisterID"] = this.cashRegisterID;
        data["phonenumber"] = this.phonenumber;
        data["defaultTime"] = this.defaultTime;
        data["pointBalance"] = this.pointBalance;
        data["greetingMessage"] = this.greetingMessage;
        data["logoLink"] = this.logoLink;
        return data;
    }
}

/** 登录后用户数据 */
export interface IUserItem {
    id?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    address?: string | undefined;
    city?: string | undefined;
    birthday?: Date | undefined;
    email?: string | undefined;
    zipCode?: string | undefined;
    storeName?: string | undefined;
    cashRegisterID?: string | undefined;
    phonenumber?: string | undefined;
    defaultTime?: string | undefined;
    pointBalance?: number | undefined;
    greetingMessage?: string | undefined;
    logoLink?: string | undefined;
}

export class RegToken implements IRegToken {
    registerToken?: string | undefined;

    constructor(data?: IRegToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.registerToken = _data["registerToken"];
        }
    }

    static fromJS(data: any): RegToken {
        data = typeof data === 'object' ? data : {};
        let result = new RegToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["registerToken"] = this.registerToken;
        return data;
    }
}

export interface IRegToken {
    registerToken?: string | undefined;
}

/** 注册后用户数据类 */
export class RegisterRequest implements IRegisterRequest {
    firstName?: string | undefined;
    lastName?: string | undefined;
    address?: string | undefined;
    city?: string | undefined;
    birthday?: string | undefined;
    email?: string | undefined;
    phonenumber?: string | undefined;
    defaultTime?: string | undefined;
    zipCode?: string | undefined;

    constructor(data?: IRegisterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.address = _data["address"];
            this.city = _data["city"];
            this.birthday = _data["birthday"];
            this.email = _data["email"];
            this.phonenumber = _data["phonenumber"];
            this.defaultTime = _data["defaultTime"];
            this.zipCode = _data["zipCode"];
        }
    }

    static fromJS(data: any): RegisterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["address"] = this.address;
        data["city"] = this.city;
        data["birthday"] = this.birthday;
        data["email"] = this.email;
        data["phonenumber"] = this.phonenumber;
        data["defaultTime"] = this.defaultTime;
        data["zipCode"] = this.zipCode;
        return data;
    }
}

/** 注册后用户数据类 */
export interface IRegisterRequest {
    firstName?: string | undefined;
    lastName?: string | undefined;
    address?: string | undefined;
    city?: string | undefined;
    birthday?: string | undefined;
    email?: string | undefined;
    phonenumber?: string | undefined;
    defaultTime?: string | undefined;
    zipCode?: string | undefined;
}

export class CustomUpdateRequest implements ICustomUpdateRequest {
    firstName?: string | undefined;
    lastName?: string | undefined;
    address?: string | undefined;
    city?: string | undefined;
    birthday?: string | undefined;
    email?: string | undefined;
    defaultTime?: string | undefined;
    zipCode?: string | undefined;

    constructor(data?: ICustomUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.address = _data["address"];
            this.city = _data["city"];
            this.birthday = _data["birthday"];
            this.email = _data["email"];
            this.defaultTime = _data["defaultTime"];
            this.zipCode = _data["zipCode"];
        }
    }

    static fromJS(data: any): CustomUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CustomUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["address"] = this.address;
        data["city"] = this.city;
        data["birthday"] = this.birthday;
        data["email"] = this.email;
        data["defaultTime"] = this.defaultTime;
        data["zipCode"] = this.zipCode;
        return data;
    }
}

export interface ICustomUpdateRequest {
    firstName?: string | undefined;
    lastName?: string | undefined;
    address?: string | undefined;
    city?: string | undefined;
    birthday?: string | undefined;
    email?: string | undefined;
    defaultTime?: string | undefined;
    zipCode?: string | undefined;
}

export class CompanyProductsDTO implements ICompanyProductsDTO {
    products?: StoreProductsDTO[] | undefined;

    constructor(data?: ICompanyProductsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(StoreProductsDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CompanyProductsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyProductsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICompanyProductsDTO {
    products?: StoreProductsDTO[] | undefined;
}

/** 商店下的商品 */
export class StoreProductsDTO implements IStoreProductsDTO {
    upc?: string | undefined;
    isScale?: number;
    everyDayLowPrice?: string | undefined;
    productName?: string | undefined;
    vendorID?: string | undefined;
    department?: string | undefined;
    itemSize?: number | undefined;
    itemUnit?: string | undefined;
    priceBase?: number;
    unitCost?: number | undefined;
    regular_Price?: number | undefined;
    pluUseSingleSplitPrice?: boolean | undefined;
    pluSingleSplitPrice?: number | undefined;
    beginDate?: Date | undefined;
    endDate?: Date | undefined;
    promoDescription?: string | undefined;
    plu_id?: string | undefined;
    last_Sold?: Date | undefined;
    last_Received?: Date | undefined;
    onHand?: number | undefined;
    deposit?: number | undefined;
    ptD30?: number | undefined;
    aisle?: string | undefined;
    store?: CompanyStoreDTO | undefined;

    constructor(data?: IStoreProductsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.upc = _data["upc"];
            this.isScale = _data["isScale"];
            this.everyDayLowPrice = _data["everyDayLowPrice"];
            this.productName = _data["productName"];
            this.vendorID = _data["vendorID"];
            this.department = _data["department"];
            this.itemSize = _data["itemSize"];
            this.itemUnit = _data["itemUnit"];
            this.priceBase = _data["priceBase"];
            this.unitCost = _data["unitCost"];
            this.regular_Price = _data["regular_Price"];
            this.pluUseSingleSplitPrice = _data["pluUseSingleSplitPrice"];
            this.pluSingleSplitPrice = _data["pluSingleSplitPrice"];
            this.beginDate = _data["beginDate"] ? new Date(_data["beginDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.promoDescription = _data["promoDescription"];
            this.plu_id = _data["plu_id"];
            this.last_Sold = _data["last_Sold"] ? new Date(_data["last_Sold"].toString()) : <any>undefined;
            this.last_Received = _data["last_Received"] ? new Date(_data["last_Received"].toString()) : <any>undefined;
            this.onHand = _data["onHand"];
            this.deposit = _data["deposit"];
            this.ptD30 = _data["ptD30"];
            this.aisle = _data["aisle"];
            this.store = _data["store"] ? CompanyStoreDTO.fromJS(_data["store"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StoreProductsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new StoreProductsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["upc"] = this.upc;
        data["isScale"] = this.isScale;
        data["everyDayLowPrice"] = this.everyDayLowPrice;
        data["productName"] = this.productName;
        data["vendorID"] = this.vendorID;
        data["department"] = this.department;
        data["itemSize"] = this.itemSize;
        data["itemUnit"] = this.itemUnit;
        data["priceBase"] = this.priceBase;
        data["unitCost"] = this.unitCost;
        data["regular_Price"] = this.regular_Price;
        data["pluUseSingleSplitPrice"] = this.pluUseSingleSplitPrice;
        data["pluSingleSplitPrice"] = this.pluSingleSplitPrice;
        data["beginDate"] = this.beginDate ? this.beginDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["promoDescription"] = this.promoDescription;
        data["plu_id"] = this.plu_id;
        data["last_Sold"] = this.last_Sold ? this.last_Sold.toISOString() : <any>undefined;
        data["last_Received"] = this.last_Received ? this.last_Received.toISOString() : <any>undefined;
        data["onHand"] = this.onHand;
        data["deposit"] = this.deposit;
        data["ptD30"] = this.ptD30;
        data["aisle"] = this.aisle;
        data["store"] = this.store ? this.store.toJSON() : <any>undefined;
        return data;
    }
}

/** 商店下的商品 */
export interface IStoreProductsDTO {
    upc?: string | undefined;
    isScale?: number;
    everyDayLowPrice?: string | undefined;
    productName?: string | undefined;
    vendorID?: string | undefined;
    department?: string | undefined;
    itemSize?: number | undefined;
    itemUnit?: string | undefined;
    priceBase?: number;
    unitCost?: number | undefined;
    regular_Price?: number | undefined;
    pluUseSingleSplitPrice?: boolean | undefined;
    pluSingleSplitPrice?: number | undefined;
    beginDate?: Date | undefined;
    endDate?: Date | undefined;
    promoDescription?: string | undefined;
    plu_id?: string | undefined;
    last_Sold?: Date | undefined;
    last_Received?: Date | undefined;
    onHand?: number | undefined;
    deposit?: number | undefined;
    ptD30?: number | undefined;
    aisle?: string | undefined;
    store?: CompanyStoreDTO | undefined;
}

export class CompanyStoreDTO implements ICompanyStoreDTO {
    storeName?: string | undefined;
    storeId?: number;

    constructor(data?: ICompanyStoreDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeName = _data["storeName"];
            this.storeId = _data["storeId"];
        }
    }

    static fromJS(data: any): CompanyStoreDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyStoreDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeName"] = this.storeName;
        data["storeId"] = this.storeId;
        return data;
    }
}

export interface ICompanyStoreDTO {
    storeName?: string | undefined;
    storeId?: number;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class ProductImageSynchronizationBody implements IProductImageSynchronizationBody {
    sourceStoreAccessKeys?: string[] | undefined;
    pluUpcs?: string[] | undefined;
    mode?: ProductImageSynchronizationMode;

    constructor(data?: IProductImageSynchronizationBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["sourceStoreAccessKeys"])) {
                this.sourceStoreAccessKeys = [] as any;
                for (let item of _data["sourceStoreAccessKeys"])
                    this.sourceStoreAccessKeys!.push(item);
            }
            if (Array.isArray(_data["pluUpcs"])) {
                this.pluUpcs = [] as any;
                for (let item of _data["pluUpcs"])
                    this.pluUpcs!.push(item);
            }
            this.mode = _data["mode"];
        }
    }

    static fromJS(data: any): ProductImageSynchronizationBody {
        data = typeof data === 'object' ? data : {};
        let result = new ProductImageSynchronizationBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.sourceStoreAccessKeys)) {
            data["sourceStoreAccessKeys"] = [];
            for (let item of this.sourceStoreAccessKeys)
                data["sourceStoreAccessKeys"].push(item);
        }
        if (Array.isArray(this.pluUpcs)) {
            data["pluUpcs"] = [];
            for (let item of this.pluUpcs)
                data["pluUpcs"].push(item);
        }
        data["mode"] = this.mode;
        return data;
    }
}

export interface IProductImageSynchronizationBody {
    sourceStoreAccessKeys?: string[] | undefined;
    pluUpcs?: string[] | undefined;
    mode?: ProductImageSynchronizationMode;
}

export enum ProductImageSynchronizationMode {
    SkipIfExists = "SkipIfExists",
    Cover = "Cover",
}

export class BarcodeInfo implements IBarcodeInfo {
    barcode?: string | undefined;
    deposit?: string | undefined;
    department?: string | undefined;

    constructor(data?: IBarcodeInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.barcode = _data["barcode"];
            this.deposit = _data["deposit"];
            this.department = _data["department"];
        }
    }

    static fromJS(data: any): BarcodeInfo {
        data = typeof data === 'object' ? data : {};
        let result = new BarcodeInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["barcode"] = this.barcode;
        data["deposit"] = this.deposit;
        data["department"] = this.department;
        return data;
    }
}

export interface IBarcodeInfo {
    barcode?: string | undefined;
    deposit?: string | undefined;
    department?: string | undefined;
}

export class BarcodesBody implements IBarcodesBody {
    barcodes?: string[] | undefined;
    storeIds?: number[] | undefined;

    constructor(data?: IBarcodesBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["barcodes"])) {
                this.barcodes = [] as any;
                for (let item of _data["barcodes"])
                    this.barcodes!.push(item);
            }
            if (Array.isArray(_data["storeIds"])) {
                this.storeIds = [] as any;
                for (let item of _data["storeIds"])
                    this.storeIds!.push(item);
            }
        }
    }

    static fromJS(data: any): BarcodesBody {
        data = typeof data === 'object' ? data : {};
        let result = new BarcodesBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.barcodes)) {
            data["barcodes"] = [];
            for (let item of this.barcodes)
                data["barcodes"].push(item);
        }
        if (Array.isArray(this.storeIds)) {
            data["storeIds"] = [];
            for (let item of this.storeIds)
                data["storeIds"].push(item);
        }
        return data;
    }
}

export interface IBarcodesBody {
    barcodes?: string[] | undefined;
    storeIds?: number[] | undefined;
}

export class ServiceResponseOfProductResult implements IServiceResponseOfProductResult {
    statues?: ServiceStatues;
    errorMessage?: string | undefined;
    responseCode?: HttpStatusCode;
    result?: ProductResult | undefined;

    constructor(data?: IServiceResponseOfProductResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statues = _data["statues"];
            this.errorMessage = _data["errorMessage"];
            this.responseCode = _data["responseCode"];
            this.result = _data["result"] ? ProductResult.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ServiceResponseOfProductResult {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseOfProductResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statues"] = this.statues;
        data["errorMessage"] = this.errorMessage;
        data["responseCode"] = this.responseCode;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IServiceResponseOfProductResult {
    statues?: ServiceStatues;
    errorMessage?: string | undefined;
    responseCode?: HttpStatusCode;
    result?: ProductResult | undefined;
}

export enum ServiceStatues {
    Success = "Success",
    Failure = "Failure",
}

export enum HttpStatusCode {
    Continue = "Continue",
    SwitchingProtocols = "SwitchingProtocols",
    Processing = "Processing",
    EarlyHints = "EarlyHints",
    OK = "OK",
    Created = "Created",
    Accepted = "Accepted",
    NonAuthoritativeInformation = "NonAuthoritativeInformation",
    NoContent = "NoContent",
    ResetContent = "ResetContent",
    PartialContent = "PartialContent",
    MultiStatus = "MultiStatus",
    AlreadyReported = "AlreadyReported",
    IMUsed = "IMUsed",
    MultipleChoices = "Ambiguous",
    Ambiguous = "Ambiguous",
    MovedPermanently = "Moved",
    Moved = "Moved",
    Found = "Redirect",
    Redirect = "Redirect",
    SeeOther = "RedirectMethod",
    RedirectMethod = "RedirectMethod",
    NotModified = "NotModified",
    UseProxy = "UseProxy",
    Unused = "Unused",
    TemporaryRedirect = "TemporaryRedirect",
    RedirectKeepVerb = "TemporaryRedirect",
    PermanentRedirect = "PermanentRedirect",
    BadRequest = "BadRequest",
    Unauthorized = "Unauthorized",
    PaymentRequired = "PaymentRequired",
    Forbidden = "Forbidden",
    NotFound = "NotFound",
    MethodNotAllowed = "MethodNotAllowed",
    NotAcceptable = "NotAcceptable",
    ProxyAuthenticationRequired = "ProxyAuthenticationRequired",
    RequestTimeout = "RequestTimeout",
    Conflict = "Conflict",
    Gone = "Gone",
    LengthRequired = "LengthRequired",
    PreconditionFailed = "PreconditionFailed",
    RequestEntityTooLarge = "RequestEntityTooLarge",
    RequestUriTooLong = "RequestUriTooLong",
    UnsupportedMediaType = "UnsupportedMediaType",
    RequestedRangeNotSatisfiable = "RequestedRangeNotSatisfiable",
    ExpectationFailed = "ExpectationFailed",
    MisdirectedRequest = "MisdirectedRequest",
    UnprocessableEntity = "UnprocessableEntity",
    Locked = "Locked",
    FailedDependency = "FailedDependency",
    UpgradeRequired = "UpgradeRequired",
    PreconditionRequired = "PreconditionRequired",
    TooManyRequests = "TooManyRequests",
    RequestHeaderFieldsTooLarge = "RequestHeaderFieldsTooLarge",
    UnavailableForLegalReasons = "UnavailableForLegalReasons",
    InternalServerError = "InternalServerError",
    NotImplemented = "NotImplemented",
    BadGateway = "BadGateway",
    ServiceUnavailable = "ServiceUnavailable",
    GatewayTimeout = "GatewayTimeout",
    HttpVersionNotSupported = "HttpVersionNotSupported",
    VariantAlsoNegotiates = "VariantAlsoNegotiates",
    InsufficientStorage = "InsufficientStorage",
    LoopDetected = "LoopDetected",
    NotExtended = "NotExtended",
    NetworkAuthenticationRequired = "NetworkAuthenticationRequired",
}

export class ProductResult implements IProductResult {
    items?: WalmartProduct[] | undefined;

    constructor(data?: IProductResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(WalmartProduct.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductResult {
        data = typeof data === 'object' ? data : {};
        let result = new ProductResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductResult {
    items?: WalmartProduct[] | undefined;
}

export class WalmartProduct implements IWalmartProduct {
    name?: string | undefined;
    categoryPath?: string | undefined;
    shortDescription?: string | undefined;
    longDescription?: string | undefined;
    brandName?: string | undefined;
    largeImage?: string | undefined;
    size?: string | undefined;
    imageEntities?: ImageEntity[] | undefined;

    constructor(data?: IWalmartProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.categoryPath = _data["categoryPath"];
            this.shortDescription = _data["shortDescription"];
            this.longDescription = _data["longDescription"];
            this.brandName = _data["brandName"];
            this.largeImage = _data["largeImage"];
            this.size = _data["size"];
            if (Array.isArray(_data["imageEntities"])) {
                this.imageEntities = [] as any;
                for (let item of _data["imageEntities"])
                    this.imageEntities!.push(ImageEntity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WalmartProduct {
        data = typeof data === 'object' ? data : {};
        let result = new WalmartProduct();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["categoryPath"] = this.categoryPath;
        data["shortDescription"] = this.shortDescription;
        data["longDescription"] = this.longDescription;
        data["brandName"] = this.brandName;
        data["largeImage"] = this.largeImage;
        data["size"] = this.size;
        if (Array.isArray(this.imageEntities)) {
            data["imageEntities"] = [];
            for (let item of this.imageEntities)
                data["imageEntities"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWalmartProduct {
    name?: string | undefined;
    categoryPath?: string | undefined;
    shortDescription?: string | undefined;
    longDescription?: string | undefined;
    brandName?: string | undefined;
    largeImage?: string | undefined;
    size?: string | undefined;
    imageEntities?: ImageEntity[] | undefined;
}

export class ImageEntity implements IImageEntity {
    largeImage?: string | undefined;
    entityType?: string | undefined;

    constructor(data?: IImageEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.largeImage = _data["largeImage"];
            this.entityType = _data["entityType"];
        }
    }

    static fromJS(data: any): ImageEntity {
        data = typeof data === 'object' ? data : {};
        let result = new ImageEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["largeImage"] = this.largeImage;
        data["entityType"] = this.entityType;
        return data;
    }
}

export interface IImageEntity {
    largeImage?: string | undefined;
    entityType?: string | undefined;
}

export class KeyValuePairedOfIntegerAndString implements IKeyValuePairedOfIntegerAndString {
    key?: number;
    value?: string | undefined;

    constructor(data?: IKeyValuePairedOfIntegerAndString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): KeyValuePairedOfIntegerAndString {
        data = typeof data === 'object' ? data : {};
        let result = new KeyValuePairedOfIntegerAndString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IKeyValuePairedOfIntegerAndString {
    key?: number;
    value?: string | undefined;
}

export class ProductInfoDto implements IProductInfoDto {
    storeID?: number;
    storeName?: string | undefined;
    productId?: string;
    productDescript?: string | undefined;
    barcode?: string | undefined;
    department?: Department | undefined;
    vendor?: Vendor | undefined;
    brand?: Brand | undefined;
    taxRuleSource?: TaxRuleSource | undefined;
    taxs?: TaxDto[] | undefined;
    price?: number;
    priceBase?: number;
    scaleSaleMode?: ScaleSaleMode | undefined;
    departmentGroup?: DepartmentGroupDto | undefined;

    constructor(data?: IProductInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeID = _data["storeID"];
            this.storeName = _data["storeName"];
            this.productId = _data["productId"];
            this.productDescript = _data["productDescript"];
            this.barcode = _data["barcode"];
            this.department = _data["department"] ? Department.fromJS(_data["department"]) : <any>undefined;
            this.vendor = _data["vendor"] ? Vendor.fromJS(_data["vendor"]) : <any>undefined;
            this.brand = _data["brand"] ? Brand.fromJS(_data["brand"]) : <any>undefined;
            this.taxRuleSource = _data["taxRuleSource"] ? TaxRuleSource.fromJS(_data["taxRuleSource"]) : <any>undefined;
            if (Array.isArray(_data["taxs"])) {
                this.taxs = [] as any;
                for (let item of _data["taxs"])
                    this.taxs!.push(TaxDto.fromJS(item));
            }
            this.price = _data["price"];
            this.priceBase = _data["priceBase"];
            this.scaleSaleMode = _data["scaleSaleMode"];
            this.departmentGroup = _data["departmentGroup"] ? DepartmentGroupDto.fromJS(_data["departmentGroup"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeID"] = this.storeID;
        data["storeName"] = this.storeName;
        data["productId"] = this.productId;
        data["productDescript"] = this.productDescript;
        data["barcode"] = this.barcode;
        data["department"] = this.department ? this.department.toJSON() : <any>undefined;
        data["vendor"] = this.vendor ? this.vendor.toJSON() : <any>undefined;
        data["brand"] = this.brand ? this.brand.toJSON() : <any>undefined;
        data["taxRuleSource"] = this.taxRuleSource ? this.taxRuleSource.toJSON() : <any>undefined;
        if (Array.isArray(this.taxs)) {
            data["taxs"] = [];
            for (let item of this.taxs)
                data["taxs"].push(item.toJSON());
        }
        data["price"] = this.price;
        data["priceBase"] = this.priceBase;
        data["scaleSaleMode"] = this.scaleSaleMode;
        data["departmentGroup"] = this.departmentGroup ? this.departmentGroup.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProductInfoDto {
    storeID?: number;
    storeName?: string | undefined;
    productId?: string;
    productDescript?: string | undefined;
    barcode?: string | undefined;
    department?: Department | undefined;
    vendor?: Vendor | undefined;
    brand?: Brand | undefined;
    taxRuleSource?: TaxRuleSource | undefined;
    taxs?: TaxDto[] | undefined;
    price?: number;
    priceBase?: number;
    scaleSaleMode?: ScaleSaleMode | undefined;
    departmentGroup?: DepartmentGroupDto | undefined;
}

export class TaxRuleSource implements ITaxRuleSource {
    id?: string | undefined;
    type?: TaxRuleSourceType;
    description?: string | undefined;

    constructor(data?: ITaxRuleSource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): TaxRuleSource {
        data = typeof data === 'object' ? data : {};
        let result = new TaxRuleSource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["description"] = this.description;
        return data;
    }
}

export interface ITaxRuleSource {
    id?: string | undefined;
    type?: TaxRuleSourceType;
    description?: string | undefined;
}

export enum TaxRuleSourceType {
    Department = "Department",
    Custom = "Custom",
}

export enum ScaleSaleMode {
    ByWeight = "ByWeight",
    ByPC = "ByPC",
}

export class UpdateProductDto implements IUpdateProductDto {
    storeId!: number;
    productId!: string;
    productDesccript?: string | undefined;
    departmentId?: number | undefined;
    vendorDesc?: string | undefined;
    brandId?: number | undefined;
    taxType?: TaxRuleSourceType | undefined;
    taxIds?: number[] | undefined;

    constructor(data?: IUpdateProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            this.productId = _data["productId"];
            this.productDesccript = _data["productDesccript"];
            this.departmentId = _data["departmentId"];
            this.vendorDesc = _data["vendorDesc"];
            this.brandId = _data["brandId"];
            this.taxType = _data["taxType"];
            if (Array.isArray(_data["taxIds"])) {
                this.taxIds = [] as any;
                for (let item of _data["taxIds"])
                    this.taxIds!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["productId"] = this.productId;
        data["productDesccript"] = this.productDesccript;
        data["departmentId"] = this.departmentId;
        data["vendorDesc"] = this.vendorDesc;
        data["brandId"] = this.brandId;
        data["taxType"] = this.taxType;
        if (Array.isArray(this.taxIds)) {
            data["taxIds"] = [];
            for (let item of this.taxIds)
                data["taxIds"].push(item);
        }
        return data;
    }
}

export interface IUpdateProductDto {
    storeId: number;
    productId: string;
    productDesccript?: string | undefined;
    departmentId?: number | undefined;
    vendorDesc?: string | undefined;
    brandId?: number | undefined;
    taxType?: TaxRuleSourceType | undefined;
    taxIds?: number[] | undefined;
}

export class ProductReportResponse implements IProductReportResponse {
    products?: ProductReport[] | undefined;

    constructor(data?: IProductReportResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(ProductReport.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductReportResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductReportResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductReportResponse {
    products?: ProductReport[] | undefined;
}

export class ProductReport implements IProductReport {
    barCode?: string | undefined;
    description?: string | undefined;
    priceBase?: number;
    price?: number;
    onhand?: number | undefined;
    lastSold?: Date | undefined;
    createdDate?: Date | undefined;

    constructor(data?: IProductReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.barCode = _data["barCode"];
            this.description = _data["description"];
            this.priceBase = _data["priceBase"];
            this.price = _data["price"];
            this.onhand = _data["onhand"];
            this.lastSold = _data["lastSold"] ? new Date(_data["lastSold"].toString()) : <any>undefined;
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductReport {
        data = typeof data === 'object' ? data : {};
        let result = new ProductReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["barCode"] = this.barCode;
        data["description"] = this.description;
        data["priceBase"] = this.priceBase;
        data["price"] = this.price;
        data["onhand"] = this.onhand;
        data["lastSold"] = this.lastSold ? this.lastSold.toISOString() : <any>undefined;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IProductReport {
    barCode?: string | undefined;
    description?: string | undefined;
    priceBase?: number;
    price?: number;
    onhand?: number | undefined;
    lastSold?: Date | undefined;
    createdDate?: Date | undefined;
}

export class GetTokenRequestDto implements IGetTokenRequestDto {
    userName!: string;
    password!: string;

    constructor(data?: IGetTokenRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): GetTokenRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetTokenRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data;
    }
}

export interface IGetTokenRequestDto {
    userName: string;
    password: string;
}

export class DiscountStoreCouponResponseDto implements IDiscountStoreCouponResponseDto {
    discountStoreCoupons?: DiscountStoreCouponDto[] | undefined;

    constructor(data?: IDiscountStoreCouponResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["discountStoreCoupons"])) {
                this.discountStoreCoupons = [] as any;
                for (let item of _data["discountStoreCoupons"])
                    this.discountStoreCoupons!.push(DiscountStoreCouponDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DiscountStoreCouponResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new DiscountStoreCouponResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.discountStoreCoupons)) {
            data["discountStoreCoupons"] = [];
            for (let item of this.discountStoreCoupons)
                data["discountStoreCoupons"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDiscountStoreCouponResponseDto {
    discountStoreCoupons?: DiscountStoreCouponDto[] | undefined;
}

export class DiscountStoreCouponDto implements IDiscountStoreCouponDto {
    storeName?: string | undefined;
    code?: string | undefined;
    description?: string | undefined;
    qty?: number;
    total?: number | undefined;

    constructor(data?: IDiscountStoreCouponDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeName = _data["storeName"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.qty = _data["qty"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): DiscountStoreCouponDto {
        data = typeof data === 'object' ? data : {};
        let result = new DiscountStoreCouponDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeName"] = this.storeName;
        data["code"] = this.code;
        data["description"] = this.description;
        data["qty"] = this.qty;
        data["total"] = this.total;
        return data;
    }
}

export interface IDiscountStoreCouponDto {
    storeName?: string | undefined;
    code?: string | undefined;
    description?: string | undefined;
    qty?: number;
    total?: number | undefined;
}

export class StoreListDto implements IStoreListDto {
    stores?: ReportStoreDto[] | undefined;

    constructor(data?: IStoreListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["stores"])) {
                this.stores = [] as any;
                for (let item of _data["stores"])
                    this.stores!.push(ReportStoreDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StoreListDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.stores)) {
            data["stores"] = [];
            for (let item of this.stores)
                data["stores"].push(item.toJSON());
        }
        return data;
    }
}

export interface IStoreListDto {
    stores?: ReportStoreDto[] | undefined;
}

export class ReportStoreDto implements IReportStoreDto {
    storeId?: number;
    storeName?: string | undefined;
    startingHourOfTheDay?: number;
    beginDayOfWeek?: number;

    constructor(data?: IReportStoreDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            this.storeName = _data["storeName"];
            this.startingHourOfTheDay = _data["startingHourOfTheDay"];
            this.beginDayOfWeek = _data["beginDayOfWeek"];
        }
    }

    static fromJS(data: any): ReportStoreDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReportStoreDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["storeName"] = this.storeName;
        data["startingHourOfTheDay"] = this.startingHourOfTheDay;
        data["beginDayOfWeek"] = this.beginDayOfWeek;
        return data;
    }
}

export interface IReportStoreDto {
    storeId?: number;
    storeName?: string | undefined;
    startingHourOfTheDay?: number;
    beginDayOfWeek?: number;
}

export class HourlySalesResponseDto implements IHourlySalesResponseDto {
    sales?: HourlySalesDto[] | undefined;

    constructor(data?: IHourlySalesResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["sales"])) {
                this.sales = [] as any;
                for (let item of _data["sales"])
                    this.sales!.push(HourlySalesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HourlySalesResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new HourlySalesResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.sales)) {
            data["sales"] = [];
            for (let item of this.sales)
                data["sales"].push(item.toJSON());
        }
        return data;
    }
}

export interface IHourlySalesResponseDto {
    sales?: HourlySalesDto[] | undefined;
}

export class HourlySalesDto implements IHourlySalesDto {
    hour?: string | undefined;
    qty?: number | undefined;
    sales?: number | undefined;
    percentage?: number | undefined;
    trxCount?: number | undefined;

    constructor(data?: IHourlySalesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hour = _data["hour"];
            this.qty = _data["qty"];
            this.sales = _data["sales"];
            this.percentage = _data["percentage"];
            this.trxCount = _data["trxCount"];
        }
    }

    static fromJS(data: any): HourlySalesDto {
        data = typeof data === 'object' ? data : {};
        let result = new HourlySalesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hour"] = this.hour;
        data["qty"] = this.qty;
        data["sales"] = this.sales;
        data["percentage"] = this.percentage;
        data["trxCount"] = this.trxCount;
        return data;
    }
}

export interface IHourlySalesDto {
    hour?: string | undefined;
    qty?: number | undefined;
    sales?: number | undefined;
    percentage?: number | undefined;
    trxCount?: number | undefined;
}

export class DepartmentGroupSalesResponseDto implements IDepartmentGroupSalesResponseDto {
    departmentGroupSalesList?: DepartmentGroupSalesDto[] | undefined;

    constructor(data?: IDepartmentGroupSalesResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["departmentGroupSalesList"])) {
                this.departmentGroupSalesList = [] as any;
                for (let item of _data["departmentGroupSalesList"])
                    this.departmentGroupSalesList!.push(DepartmentGroupSalesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DepartmentGroupSalesResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentGroupSalesResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.departmentGroupSalesList)) {
            data["departmentGroupSalesList"] = [];
            for (let item of this.departmentGroupSalesList)
                data["departmentGroupSalesList"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDepartmentGroupSalesResponseDto {
    departmentGroupSalesList?: DepartmentGroupSalesDto[] | undefined;
}

export class DepartmentGroupSalesDto implements IDepartmentGroupSalesDto {
    department?: string | undefined;
    group?: string | undefined;
    qty?: number | undefined;
    sales?: number | undefined;
    trxCount?: number | undefined;
    avgItemsTrx?: number | undefined;

    constructor(data?: IDepartmentGroupSalesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.department = _data["department"];
            this.group = _data["group"];
            this.qty = _data["qty"];
            this.sales = _data["sales"];
            this.trxCount = _data["trxCount"];
            this.avgItemsTrx = _data["avgItemsTrx"];
        }
    }

    static fromJS(data: any): DepartmentGroupSalesDto {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentGroupSalesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["department"] = this.department;
        data["group"] = this.group;
        data["qty"] = this.qty;
        data["sales"] = this.sales;
        data["trxCount"] = this.trxCount;
        data["avgItemsTrx"] = this.avgItemsTrx;
        return data;
    }
}

export interface IDepartmentGroupSalesDto {
    department?: string | undefined;
    group?: string | undefined;
    qty?: number | undefined;
    sales?: number | undefined;
    trxCount?: number | undefined;
    avgItemsTrx?: number | undefined;
}

export class TenderResponse implements ITenderResponse {
    tenders?: Tender[] | undefined;

    constructor(data?: ITenderResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["tenders"])) {
                this.tenders = [] as any;
                for (let item of _data["tenders"])
                    this.tenders!.push(Tender.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TenderResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TenderResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.tenders)) {
            data["tenders"] = [];
            for (let item of this.tenders)
                data["tenders"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITenderResponse {
    tenders?: Tender[] | undefined;
}

export class Tender implements ITender {
    description?: string | undefined;
    amount?: number;
    count?: number;

    constructor(data?: ITender) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.amount = _data["amount"];
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): Tender {
        data = typeof data === 'object' ? data : {};
        let result = new Tender();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["amount"] = this.amount;
        data["count"] = this.count;
        return data;
    }
}

export interface ITender {
    description?: string | undefined;
    amount?: number;
    count?: number;
}

export class SummaryResponseDto implements ISummaryResponseDto {
    regularRevenue?: number | undefined;
    returnQty?: number | undefined;
    return?: number | undefined;
    waste?: number | undefined;
    tax?: number | undefined;
    otherRevenue?: number | undefined;
    custCount?: number | undefined;
    loyaltyCustomer?: number | undefined;
    currentTime?: Date | undefined;
    beginDatetime?: string | undefined;
    endDatetime?: string | undefined;

    constructor(data?: ISummaryResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.regularRevenue = _data["regularRevenue"];
            this.returnQty = _data["returnQty"];
            this.return = _data["return"];
            this.waste = _data["waste"];
            this.tax = _data["tax"];
            this.otherRevenue = _data["otherRevenue"];
            this.custCount = _data["custCount"];
            this.loyaltyCustomer = _data["loyaltyCustomer"];
            this.currentTime = _data["currentTime"] ? new Date(_data["currentTime"].toString()) : <any>undefined;
            this.beginDatetime = _data["beginDatetime"];
            this.endDatetime = _data["endDatetime"];
        }
    }

    static fromJS(data: any): SummaryResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new SummaryResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["regularRevenue"] = this.regularRevenue;
        data["returnQty"] = this.returnQty;
        data["return"] = this.return;
        data["waste"] = this.waste;
        data["tax"] = this.tax;
        data["otherRevenue"] = this.otherRevenue;
        data["custCount"] = this.custCount;
        data["loyaltyCustomer"] = this.loyaltyCustomer;
        data["currentTime"] = this.currentTime ? this.currentTime.toISOString() : <any>undefined;
        data["beginDatetime"] = this.beginDatetime;
        data["endDatetime"] = this.endDatetime;
        return data;
    }
}

export interface ISummaryResponseDto {
    regularRevenue?: number | undefined;
    returnQty?: number | undefined;
    return?: number | undefined;
    waste?: number | undefined;
    tax?: number | undefined;
    otherRevenue?: number | undefined;
    custCount?: number | undefined;
    loyaltyCustomer?: number | undefined;
    currentTime?: Date | undefined;
    beginDatetime?: string | undefined;
    endDatetime?: string | undefined;
}

export class HelloReply2Dto implements IHelloReply2Dto {
    message?: string | undefined;

    constructor(data?: IHelloReply2Dto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): HelloReply2Dto {
        data = typeof data === 'object' ? data : {};
        let result = new HelloReply2Dto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        return data;
    }
}

export interface IHelloReply2Dto {
    message?: string | undefined;
}

export class SettingConfigResponse implements ISettingConfigResponse {
    items?: SettingConfigItem[] | undefined;

    constructor(data?: ISettingConfigResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SettingConfigItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SettingConfigResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SettingConfigResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISettingConfigResponse {
    items?: SettingConfigItem[] | undefined;
}

export class SettingConfigItem implements ISettingConfigItem {
    filedName?: string | undefined;
    visibilityStatus?: FieldVisibility;
    selectStatus?: FieldSelection;

    constructor(data?: ISettingConfigItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filedName = _data["filedName"];
            this.visibilityStatus = _data["visibilityStatus"];
            this.selectStatus = _data["selectStatus"];
        }
    }

    static fromJS(data: any): SettingConfigItem {
        data = typeof data === 'object' ? data : {};
        let result = new SettingConfigItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filedName"] = this.filedName;
        data["visibilityStatus"] = this.visibilityStatus;
        data["selectStatus"] = this.selectStatus;
        return data;
    }
}

export interface ISettingConfigItem {
    filedName?: string | undefined;
    visibilityStatus?: FieldVisibility;
    selectStatus?: FieldSelection;
}

export enum FieldVisibility {
    Show = "Show",
    Hide = "Hide",
}

export enum FieldSelection {
    Required = "Required",
    Optional = "Optional",
}

export class SharedTemplate implements ISharedTemplate {
    templates?: Template[] | undefined;

    constructor(data?: ISharedTemplate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["templates"])) {
                this.templates = [] as any;
                for (let item of _data["templates"])
                    this.templates!.push(Template.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SharedTemplate {
        data = typeof data === 'object' ? data : {};
        let result = new SharedTemplate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.templates)) {
            data["templates"] = [];
            for (let item of this.templates)
                data["templates"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISharedTemplate {
    templates?: Template[] | undefined;
}

export class Template implements ITemplate {
    id?: string | undefined;
    templateName?: string | undefined;
    storeId?: number;

    constructor(data?: ITemplate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.templateName = _data["templateName"];
            this.storeId = _data["storeId"];
        }
    }

    static fromJS(data: any): Template {
        data = typeof data === 'object' ? data : {};
        let result = new Template();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["templateName"] = this.templateName;
        data["storeId"] = this.storeId;
        return data;
    }
}

export interface ITemplate {
    id?: string | undefined;
    templateName?: string | undefined;
    storeId?: number;
}

export class SearchTemplate implements ISearchTemplate {
    id?: string | undefined;
    templateName?: string | undefined;
    templateJson?: string | undefined;
    lastModified?: Date | undefined;
    created?: Date | undefined;

    constructor(data?: ISearchTemplate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.templateName = _data["templateName"];
            this.templateJson = _data["templateJson"];
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SearchTemplate {
        data = typeof data === 'object' ? data : {};
        let result = new SearchTemplate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["templateName"] = this.templateName;
        data["templateJson"] = this.templateJson;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        return data;
    }
}

export interface ISearchTemplate {
    id?: string | undefined;
    templateName?: string | undefined;
    templateJson?: string | undefined;
    lastModified?: Date | undefined;
    created?: Date | undefined;
}

export enum StoreChainCodeType {
    Internal = "Internal",
    Normal = "Normal",
    None = "None",
}

export class StoreChainCodeInfo implements IStoreChainCodeInfo {
    id?: string | undefined;
    colorId?: number;
    desc?: string | undefined;
    barcode?: string | undefined;
    departmentDesc?: string | undefined;
    vendorDesc?: string | undefined;
    brandDesc?: string | undefined;
    price?: number;
    priceBase?: number;
    scaleSaleMode?: ScaleSaleMode | undefined;
    chainCode?: string | undefined;
    chainDepartment?: string | undefined;
    chainDescription?: string | undefined;
    storeID?: number;
    storeName?: string | undefined;

    constructor(data?: IStoreChainCodeInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.colorId = _data["colorId"];
            this.desc = _data["desc"];
            this.barcode = _data["barcode"];
            this.departmentDesc = _data["departmentDesc"];
            this.vendorDesc = _data["vendorDesc"];
            this.brandDesc = _data["brandDesc"];
            this.price = _data["price"];
            this.priceBase = _data["priceBase"];
            this.scaleSaleMode = _data["scaleSaleMode"];
            this.chainCode = _data["chainCode"];
            this.chainDepartment = _data["chainDepartment"];
            this.chainDescription = _data["chainDescription"];
            this.storeID = _data["storeID"];
            this.storeName = _data["storeName"];
        }
    }

    static fromJS(data: any): StoreChainCodeInfo {
        data = typeof data === 'object' ? data : {};
        let result = new StoreChainCodeInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["colorId"] = this.colorId;
        data["desc"] = this.desc;
        data["barcode"] = this.barcode;
        data["departmentDesc"] = this.departmentDesc;
        data["vendorDesc"] = this.vendorDesc;
        data["brandDesc"] = this.brandDesc;
        data["price"] = this.price;
        data["priceBase"] = this.priceBase;
        data["scaleSaleMode"] = this.scaleSaleMode;
        data["chainCode"] = this.chainCode;
        data["chainDepartment"] = this.chainDepartment;
        data["chainDescription"] = this.chainDescription;
        data["storeID"] = this.storeID;
        data["storeName"] = this.storeName;
        return data;
    }
}

export interface IStoreChainCodeInfo {
    id?: string | undefined;
    colorId?: number;
    desc?: string | undefined;
    barcode?: string | undefined;
    departmentDesc?: string | undefined;
    vendorDesc?: string | undefined;
    brandDesc?: string | undefined;
    price?: number;
    priceBase?: number;
    scaleSaleMode?: ScaleSaleMode | undefined;
    chainCode?: string | undefined;
    chainDepartment?: string | undefined;
    chainDescription?: string | undefined;
    storeID?: number;
    storeName?: string | undefined;
}

export class UpdateProductChainCodeDto implements IUpdateProductChainCodeDto {
    storeCode?: KeyValuePairedOfIntegerAndString[] | undefined;
    chainCodeInfo?: StoreChainCodeUpdateRequest | undefined;

    constructor(data?: IUpdateProductChainCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["storeCode"])) {
                this.storeCode = [] as any;
                for (let item of _data["storeCode"])
                    this.storeCode!.push(KeyValuePairedOfIntegerAndString.fromJS(item));
            }
            this.chainCodeInfo = _data["chainCodeInfo"] ? StoreChainCodeUpdateRequest.fromJS(_data["chainCodeInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateProductChainCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductChainCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.storeCode)) {
            data["storeCode"] = [];
            for (let item of this.storeCode)
                data["storeCode"].push(item.toJSON());
        }
        data["chainCodeInfo"] = this.chainCodeInfo ? this.chainCodeInfo.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateProductChainCodeDto {
    storeCode?: KeyValuePairedOfIntegerAndString[] | undefined;
    chainCodeInfo?: StoreChainCodeUpdateRequest | undefined;
}

export class StoreChainCodeUpdateRequest implements IStoreChainCodeUpdateRequest {
    chainCode?: string | undefined;
    chainDepartment?: string | undefined;
    chainDescription?: string | undefined;

    constructor(data?: IStoreChainCodeUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.chainCode = _data["chainCode"];
            this.chainDepartment = _data["chainDepartment"];
            this.chainDescription = _data["chainDescription"];
        }
    }

    static fromJS(data: any): StoreChainCodeUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new StoreChainCodeUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chainCode"] = this.chainCode;
        data["chainDepartment"] = this.chainDepartment;
        data["chainDescription"] = this.chainDescription;
        return data;
    }
}

export interface IStoreChainCodeUpdateRequest {
    chainCode?: string | undefined;
    chainDepartment?: string | undefined;
    chainDescription?: string | undefined;
}

export class KeyValuePairedOfIntegerAndBoolean implements IKeyValuePairedOfIntegerAndBoolean {
    key?: number;
    value?: boolean;

    constructor(data?: IKeyValuePairedOfIntegerAndBoolean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): KeyValuePairedOfIntegerAndBoolean {
        data = typeof data === 'object' ? data : {};
        let result = new KeyValuePairedOfIntegerAndBoolean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IKeyValuePairedOfIntegerAndBoolean {
    key?: number;
    value?: boolean;
}

export class StoreDataCloneBody implements IStoreDataCloneBody {
    currentStore!: number;
    targentStore!: number;
    barCodes!: string[];

    constructor(data?: IStoreDataCloneBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.barCodes = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentStore = _data["currentStore"];
            this.targentStore = _data["targentStore"];
            if (Array.isArray(_data["barCodes"])) {
                this.barCodes = [] as any;
                for (let item of _data["barCodes"])
                    this.barCodes!.push(item);
            }
        }
    }

    static fromJS(data: any): StoreDataCloneBody {
        data = typeof data === 'object' ? data : {};
        let result = new StoreDataCloneBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentStore"] = this.currentStore;
        data["targentStore"] = this.targentStore;
        if (Array.isArray(this.barCodes)) {
            data["barCodes"] = [];
            for (let item of this.barCodes)
                data["barCodes"].push(item);
        }
        return data;
    }
}

export interface IStoreDataCloneBody {
    currentStore: number;
    targentStore: number;
    barCodes: string[];
}

export enum SearchType {
    Text = "Text",
    UPC = "UPC",
}

export class StoreInventoryDto implements IStoreInventoryDto {
    storeId?: number;
    storeName?: string | undefined;
    wareHouseID?: string | undefined;
    wareHouseName?: string | undefined;
    /** 商品条码 */
    upc?: string | undefined;
    /** 商品名 */
    productDescription?: string | undefined;
    brandDesc?: string | undefined;
    vendorDesc?: string | undefined;
    departmentDesc?: string | undefined;
    /** 库存 */
    onHand?: string | undefined;

    constructor(data?: IStoreInventoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            this.storeName = _data["storeName"];
            this.wareHouseID = _data["wareHouseID"];
            this.wareHouseName = _data["wareHouseName"];
            this.upc = _data["upc"];
            this.productDescription = _data["productDescription"];
            this.brandDesc = _data["brandDesc"];
            this.vendorDesc = _data["vendorDesc"];
            this.departmentDesc = _data["departmentDesc"];
            this.onHand = _data["onHand"];
        }
    }

    static fromJS(data: any): StoreInventoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreInventoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["storeName"] = this.storeName;
        data["wareHouseID"] = this.wareHouseID;
        data["wareHouseName"] = this.wareHouseName;
        data["upc"] = this.upc;
        data["productDescription"] = this.productDescription;
        data["brandDesc"] = this.brandDesc;
        data["vendorDesc"] = this.vendorDesc;
        data["departmentDesc"] = this.departmentDesc;
        data["onHand"] = this.onHand;
        return data;
    }
}

export interface IStoreInventoryDto {
    storeId?: number;
    storeName?: string | undefined;
    wareHouseID?: string | undefined;
    wareHouseName?: string | undefined;
    /** 商品条码 */
    upc?: string | undefined;
    /** 商品名 */
    productDescription?: string | undefined;
    brandDesc?: string | undefined;
    vendorDesc?: string | undefined;
    departmentDesc?: string | undefined;
    /** 库存 */
    onHand?: string | undefined;
}

export class SearchStoreInventroyRequest implements ISearchStoreInventroyRequest {
    storeIdList!: number[];
    barCodeList!: string[];

    constructor(data?: ISearchStoreInventroyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.storeIdList = [];
            this.barCodeList = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["storeIdList"])) {
                this.storeIdList = [] as any;
                for (let item of _data["storeIdList"])
                    this.storeIdList!.push(item);
            }
            if (Array.isArray(_data["barCodeList"])) {
                this.barCodeList = [] as any;
                for (let item of _data["barCodeList"])
                    this.barCodeList!.push(item);
            }
        }
    }

    static fromJS(data: any): SearchStoreInventroyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SearchStoreInventroyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.storeIdList)) {
            data["storeIdList"] = [];
            for (let item of this.storeIdList)
                data["storeIdList"].push(item);
        }
        if (Array.isArray(this.barCodeList)) {
            data["barCodeList"] = [];
            for (let item of this.barCodeList)
                data["barCodeList"].push(item);
        }
        return data;
    }
}

export interface ISearchStoreInventroyRequest {
    storeIdList: number[];
    barCodeList: string[];
}

export class GetTransferResponseDto implements IGetTransferResponseDto {
    description?: string | undefined;
    id?: string;
    currentStore?: StoreInfoDto | undefined;
    targetStore?: StoreInfoDto | undefined;
    currentWareHouse?: WareHouseInfoDto | undefined;
    targetWareHouse?: WareHouseInfoDto | undefined;
    createdDate?: Date | undefined;
    transferDate?: Date | undefined;
    receivedDate?: Date | undefined;
    transferStatus?: TransferStatus;
    /** 商品总数量 */
    totalQty?: number;
    /** 商品条目数量 */
    itemCount?: number;
    transferProductInfos?: TransferProductInfo[] | undefined;

    constructor(data?: IGetTransferResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.id = _data["id"];
            this.currentStore = _data["currentStore"] ? StoreInfoDto.fromJS(_data["currentStore"]) : <any>undefined;
            this.targetStore = _data["targetStore"] ? StoreInfoDto.fromJS(_data["targetStore"]) : <any>undefined;
            this.currentWareHouse = _data["currentWareHouse"] ? WareHouseInfoDto.fromJS(_data["currentWareHouse"]) : <any>undefined;
            this.targetWareHouse = _data["targetWareHouse"] ? WareHouseInfoDto.fromJS(_data["targetWareHouse"]) : <any>undefined;
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.transferDate = _data["transferDate"] ? new Date(_data["transferDate"].toString()) : <any>undefined;
            this.receivedDate = _data["receivedDate"] ? new Date(_data["receivedDate"].toString()) : <any>undefined;
            this.transferStatus = _data["transferStatus"];
            this.totalQty = _data["totalQty"];
            this.itemCount = _data["itemCount"];
            if (Array.isArray(_data["transferProductInfos"])) {
                this.transferProductInfos = [] as any;
                for (let item of _data["transferProductInfos"])
                    this.transferProductInfos!.push(TransferProductInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTransferResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetTransferResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["id"] = this.id;
        data["currentStore"] = this.currentStore ? this.currentStore.toJSON() : <any>undefined;
        data["targetStore"] = this.targetStore ? this.targetStore.toJSON() : <any>undefined;
        data["currentWareHouse"] = this.currentWareHouse ? this.currentWareHouse.toJSON() : <any>undefined;
        data["targetWareHouse"] = this.targetWareHouse ? this.targetWareHouse.toJSON() : <any>undefined;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["transferDate"] = this.transferDate ? this.transferDate.toISOString() : <any>undefined;
        data["receivedDate"] = this.receivedDate ? this.receivedDate.toISOString() : <any>undefined;
        data["transferStatus"] = this.transferStatus;
        data["totalQty"] = this.totalQty;
        data["itemCount"] = this.itemCount;
        if (Array.isArray(this.transferProductInfos)) {
            data["transferProductInfos"] = [];
            for (let item of this.transferProductInfos)
                data["transferProductInfos"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetTransferResponseDto {
    description?: string | undefined;
    id?: string;
    currentStore?: StoreInfoDto | undefined;
    targetStore?: StoreInfoDto | undefined;
    currentWareHouse?: WareHouseInfoDto | undefined;
    targetWareHouse?: WareHouseInfoDto | undefined;
    createdDate?: Date | undefined;
    transferDate?: Date | undefined;
    receivedDate?: Date | undefined;
    transferStatus?: TransferStatus;
    /** 商品总数量 */
    totalQty?: number;
    /** 商品条目数量 */
    itemCount?: number;
    transferProductInfos?: TransferProductInfo[] | undefined;
}

export class StoreInfoDto implements IStoreInfoDto {
    id?: number;
    storeName?: string | undefined;

    constructor(data?: IStoreInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.storeName = _data["storeName"];
        }
    }

    static fromJS(data: any): StoreInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["storeName"] = this.storeName;
        return data;
    }
}

export interface IStoreInfoDto {
    id?: number;
    storeName?: string | undefined;
}

export class WareHouseInfoDto implements IWareHouseInfoDto {
    wareHouseId?: string;
    wareHouseDesc?: string | undefined;

    constructor(data?: IWareHouseInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wareHouseId = _data["wareHouseId"];
            this.wareHouseDesc = _data["wareHouseDesc"];
        }
    }

    static fromJS(data: any): WareHouseInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new WareHouseInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wareHouseId"] = this.wareHouseId;
        data["wareHouseDesc"] = this.wareHouseDesc;
        return data;
    }
}

export interface IWareHouseInfoDto {
    wareHouseId?: string;
    wareHouseDesc?: string | undefined;
}

export enum TransferStatus {
    Dispatched = "Dispatched",
    Received = "Received",
    JustCreated = "JustCreated",
}

export class TransferProductInfo implements ITransferProductInfo {
    barCode?: string | undefined;
    desciption?: string | undefined;
    transferQty?: number;
    receiveQty?: number | undefined;

    constructor(data?: ITransferProductInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.barCode = _data["barCode"];
            this.desciption = _data["desciption"];
            this.transferQty = _data["transferQty"];
            this.receiveQty = _data["receiveQty"];
        }
    }

    static fromJS(data: any): TransferProductInfo {
        data = typeof data === 'object' ? data : {};
        let result = new TransferProductInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["barCode"] = this.barCode;
        data["desciption"] = this.desciption;
        data["transferQty"] = this.transferQty;
        data["receiveQty"] = this.receiveQty;
        return data;
    }
}

export interface ITransferProductInfo {
    barCode?: string | undefined;
    desciption?: string | undefined;
    transferQty?: number;
    receiveQty?: number | undefined;
}

export class CreateTransferRequestDto implements ICreateTransferRequestDto {
    description?: string | undefined;
    currentStore?: number;
    targetStore?: number;
    currentWareHouse?: string;
    targetWareHouse?: string;
    transferProductInfos?: TransferProductInfo[] | undefined;

    constructor(data?: ICreateTransferRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.currentStore = _data["currentStore"];
            this.targetStore = _data["targetStore"];
            this.currentWareHouse = _data["currentWareHouse"];
            this.targetWareHouse = _data["targetWareHouse"];
            if (Array.isArray(_data["transferProductInfos"])) {
                this.transferProductInfos = [] as any;
                for (let item of _data["transferProductInfos"])
                    this.transferProductInfos!.push(TransferProductInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateTransferRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTransferRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["currentStore"] = this.currentStore;
        data["targetStore"] = this.targetStore;
        data["currentWareHouse"] = this.currentWareHouse;
        data["targetWareHouse"] = this.targetWareHouse;
        if (Array.isArray(this.transferProductInfos)) {
            data["transferProductInfos"] = [];
            for (let item of this.transferProductInfos)
                data["transferProductInfos"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateTransferRequestDto {
    description?: string | undefined;
    currentStore?: number;
    targetStore?: number;
    currentWareHouse?: string;
    targetWareHouse?: string;
    transferProductInfos?: TransferProductInfo[] | undefined;
}

export class UpdateStoreInventoryDto implements IUpdateStoreInventoryDto {
    storeId!: number;
    userId?: number;
    wareHouseId!: string;
    barcode!: string;
    onHand!: number;

    constructor(data?: IUpdateStoreInventoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            this.userId = _data["userId"];
            this.wareHouseId = _data["wareHouseId"];
            this.barcode = _data["barcode"];
            this.onHand = _data["onHand"];
        }
    }

    static fromJS(data: any): UpdateStoreInventoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateStoreInventoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["userId"] = this.userId;
        data["wareHouseId"] = this.wareHouseId;
        data["barcode"] = this.barcode;
        data["onHand"] = this.onHand;
        return data;
    }
}

export interface IUpdateStoreInventoryDto {
    storeId: number;
    userId?: number;
    wareHouseId: string;
    barcode: string;
    onHand: number;
}

export class DepartmentDifferenceReportDto implements IDepartmentDifferenceReportDto {
    departmentName?: string | undefined;
    groupName?: string | undefined;
    groupNumber?: string | undefined;
    unitsSoldFirst?: number;
    unitsSoldLast?: number;
    unitsSoldDifference?: number;
    totalSaleFirst?: number;
    totalSaleLast?: number;
    totalSaleDifference?: number;
    transactionsFirst?: number;
    transactionsLast?: number;
    transactionsDifference?: number;
    transactionAvgFirst?: number | undefined;
    transactionAvgLast?: number | undefined;
    transactionAvgDifference?: number | undefined;

    constructor(data?: IDepartmentDifferenceReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.departmentName = _data["departmentName"];
            this.groupName = _data["groupName"];
            this.groupNumber = _data["groupNumber"];
            this.unitsSoldFirst = _data["unitsSoldFirst"];
            this.unitsSoldLast = _data["unitsSoldLast"];
            this.unitsSoldDifference = _data["unitsSoldDifference"];
            this.totalSaleFirst = _data["totalSaleFirst"];
            this.totalSaleLast = _data["totalSaleLast"];
            this.totalSaleDifference = _data["totalSaleDifference"];
            this.transactionsFirst = _data["transactionsFirst"];
            this.transactionsLast = _data["transactionsLast"];
            this.transactionsDifference = _data["transactionsDifference"];
            this.transactionAvgFirst = _data["transactionAvgFirst"];
            this.transactionAvgLast = _data["transactionAvgLast"];
            this.transactionAvgDifference = _data["transactionAvgDifference"];
        }
    }

    static fromJS(data: any): DepartmentDifferenceReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentDifferenceReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["departmentName"] = this.departmentName;
        data["groupName"] = this.groupName;
        data["groupNumber"] = this.groupNumber;
        data["unitsSoldFirst"] = this.unitsSoldFirst;
        data["unitsSoldLast"] = this.unitsSoldLast;
        data["unitsSoldDifference"] = this.unitsSoldDifference;
        data["totalSaleFirst"] = this.totalSaleFirst;
        data["totalSaleLast"] = this.totalSaleLast;
        data["totalSaleDifference"] = this.totalSaleDifference;
        data["transactionsFirst"] = this.transactionsFirst;
        data["transactionsLast"] = this.transactionsLast;
        data["transactionsDifference"] = this.transactionsDifference;
        data["transactionAvgFirst"] = this.transactionAvgFirst;
        data["transactionAvgLast"] = this.transactionAvgLast;
        data["transactionAvgDifference"] = this.transactionAvgDifference;
        return data;
    }
}

export interface IDepartmentDifferenceReportDto {
    departmentName?: string | undefined;
    groupName?: string | undefined;
    groupNumber?: string | undefined;
    unitsSoldFirst?: number;
    unitsSoldLast?: number;
    unitsSoldDifference?: number;
    totalSaleFirst?: number;
    totalSaleLast?: number;
    totalSaleDifference?: number;
    transactionsFirst?: number;
    transactionsLast?: number;
    transactionsDifference?: number;
    transactionAvgFirst?: number | undefined;
    transactionAvgLast?: number | undefined;
    transactionAvgDifference?: number | undefined;
}

export class DepartmentBodys implements IDepartmentBodys {
    firstBody!: DepartmentBody;
    lastBody!: DepartmentBody;

    constructor(data?: IDepartmentBodys) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.firstBody = new DepartmentBody();
            this.lastBody = new DepartmentBody();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstBody = _data["firstBody"] ? DepartmentBody.fromJS(_data["firstBody"]) : new DepartmentBody();
            this.lastBody = _data["lastBody"] ? DepartmentBody.fromJS(_data["lastBody"]) : new DepartmentBody();
        }
    }

    static fromJS(data: any): DepartmentBodys {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentBodys();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstBody"] = this.firstBody ? this.firstBody.toJSON() : <any>undefined;
        data["lastBody"] = this.lastBody ? this.lastBody.toJSON() : <any>undefined;
        return data;
    }
}

export interface IDepartmentBodys {
    firstBody: DepartmentBody;
    lastBody: DepartmentBody;
}

export class DepartmentBody implements IDepartmentBody {
    storeIds!: number[];
    beginDate!: string;
    endDate!: string;

    constructor(data?: IDepartmentBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.storeIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["storeIds"])) {
                this.storeIds = [] as any;
                for (let item of _data["storeIds"])
                    this.storeIds!.push(item);
            }
            this.beginDate = _data["beginDate"];
            this.endDate = _data["endDate"];
        }
    }

    static fromJS(data: any): DepartmentBody {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.storeIds)) {
            data["storeIds"] = [];
            for (let item of this.storeIds)
                data["storeIds"].push(item);
        }
        data["beginDate"] = this.beginDate;
        data["endDate"] = this.endDate;
        return data;
    }
}

export interface IDepartmentBody {
    storeIds: number[];
    beginDate: string;
    endDate: string;
}

export enum ReportType {
    Store = "Store",
    Department = "Department",
}

export class GroupDifferenceReportDto implements IGroupDifferenceReportDto {
    firstTotalCount?: number;
    lastTotalCount?: number;
    totalDifference?: number;
    groupsDifferences?: GroupDifferenceDto[] | undefined;

    constructor(data?: IGroupDifferenceReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstTotalCount = _data["firstTotalCount"];
            this.lastTotalCount = _data["lastTotalCount"];
            this.totalDifference = _data["totalDifference"];
            if (Array.isArray(_data["groupsDifferences"])) {
                this.groupsDifferences = [] as any;
                for (let item of _data["groupsDifferences"])
                    this.groupsDifferences!.push(GroupDifferenceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GroupDifferenceReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupDifferenceReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstTotalCount"] = this.firstTotalCount;
        data["lastTotalCount"] = this.lastTotalCount;
        data["totalDifference"] = this.totalDifference;
        if (Array.isArray(this.groupsDifferences)) {
            data["groupsDifferences"] = [];
            for (let item of this.groupsDifferences)
                data["groupsDifferences"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGroupDifferenceReportDto {
    firstTotalCount?: number;
    lastTotalCount?: number;
    totalDifference?: number;
    groupsDifferences?: GroupDifferenceDto[] | undefined;
}

export class GroupDifferenceDto implements IGroupDifferenceDto {
    groupName?: string | undefined;
    firstCount?: number;
    lastCount?: number;
    difference?: number;

    constructor(data?: IGroupDifferenceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupName = _data["groupName"];
            this.firstCount = _data["firstCount"];
            this.lastCount = _data["lastCount"];
            this.difference = _data["difference"];
        }
    }

    static fromJS(data: any): GroupDifferenceDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupDifferenceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupName"] = this.groupName;
        data["firstCount"] = this.firstCount;
        data["lastCount"] = this.lastCount;
        data["difference"] = this.difference;
        return data;
    }
}

export interface IGroupDifferenceDto {
    groupName?: string | undefined;
    firstCount?: number;
    lastCount?: number;
    difference?: number;
}

export class StoreGroupComparisonDto implements IStoreGroupComparisonDto {
    groupName?: string | undefined;
    groupNumber?: string | undefined;
    storeName?: string | undefined;
    storeId?: number;
    totalSale?: number;
    unitsSold?: number;
    transactions?: number;
    transactionAvg?: number | undefined;

    constructor(data?: IStoreGroupComparisonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupName = _data["groupName"];
            this.groupNumber = _data["groupNumber"];
            this.storeName = _data["storeName"];
            this.storeId = _data["storeId"];
            this.totalSale = _data["totalSale"];
            this.unitsSold = _data["unitsSold"];
            this.transactions = _data["transactions"];
            this.transactionAvg = _data["transactionAvg"];
        }
    }

    static fromJS(data: any): StoreGroupComparisonDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreGroupComparisonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupName"] = this.groupName;
        data["groupNumber"] = this.groupNumber;
        data["storeName"] = this.storeName;
        data["storeId"] = this.storeId;
        data["totalSale"] = this.totalSale;
        data["unitsSold"] = this.unitsSold;
        data["transactions"] = this.transactions;
        data["transactionAvg"] = this.transactionAvg;
        return data;
    }
}

export interface IStoreGroupComparisonDto {
    groupName?: string | undefined;
    groupNumber?: string | undefined;
    storeName?: string | undefined;
    storeId?: number;
    totalSale?: number;
    unitsSold?: number;
    transactions?: number;
    transactionAvg?: number | undefined;
}

export class SalesRankingDto implements ISalesRankingDto {
    barcode?: string | undefined;
    description?: string | undefined;
    qtySold?: number;
    sales?: number;
    imageUrl?: string | undefined;

    constructor(data?: ISalesRankingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.barcode = _data["barcode"];
            this.description = _data["description"];
            this.qtySold = _data["qtySold"];
            this.sales = _data["sales"];
            this.imageUrl = _data["imageUrl"];
        }
    }

    static fromJS(data: any): SalesRankingDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalesRankingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["barcode"] = this.barcode;
        data["description"] = this.description;
        data["qtySold"] = this.qtySold;
        data["sales"] = this.sales;
        data["imageUrl"] = this.imageUrl;
        return data;
    }
}

export interface ISalesRankingDto {
    barcode?: string | undefined;
    description?: string | undefined;
    qtySold?: number;
    sales?: number;
    imageUrl?: string | undefined;
}

export class StoresDTO implements IStoresDTO {
    stores?: StoreDTO[] | undefined;

    constructor(data?: IStoresDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["stores"])) {
                this.stores = [] as any;
                for (let item of _data["stores"])
                    this.stores!.push(StoreDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StoresDTO {
        data = typeof data === 'object' ? data : {};
        let result = new StoresDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.stores)) {
            data["stores"] = [];
            for (let item of this.stores)
                data["stores"].push(item.toJSON());
        }
        return data;
    }
}

export interface IStoresDTO {
    stores?: StoreDTO[] | undefined;
}

export class StoreDTO implements IStoreDTO {
    id?: number;
    encryptedId?: string | undefined;
    storename?: string | undefined;
    startingHourOfTheDay?: number;
    beginDayOfWeek?: DayOfWeek;
    dataMinerAccessKey?: string | undefined;
    companyId?: number | undefined;
    companyName?: string | undefined;
    storeSetting?: string | undefined;
    connectionStatus?: string | undefined;
    pointBalanceAccessKey?: string | undefined;
    greetingMessage?: string | undefined;
    logoLink?: string | undefined;

    constructor(data?: IStoreDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.encryptedId = _data["encryptedId"];
            this.storename = _data["storename"];
            this.startingHourOfTheDay = _data["startingHourOfTheDay"];
            this.beginDayOfWeek = _data["beginDayOfWeek"];
            this.dataMinerAccessKey = _data["dataMinerAccessKey"];
            this.companyId = _data["companyId"];
            this.companyName = _data["companyName"];
            this.storeSetting = _data["storeSetting"];
            this.connectionStatus = _data["connectionStatus"];
            this.pointBalanceAccessKey = _data["pointBalanceAccessKey"];
            this.greetingMessage = _data["greetingMessage"];
            this.logoLink = _data["logoLink"];
        }
    }

    static fromJS(data: any): StoreDTO {
        data = typeof data === 'object' ? data : {};
        let result = new StoreDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["encryptedId"] = this.encryptedId;
        data["storename"] = this.storename;
        data["startingHourOfTheDay"] = this.startingHourOfTheDay;
        data["beginDayOfWeek"] = this.beginDayOfWeek;
        data["dataMinerAccessKey"] = this.dataMinerAccessKey;
        data["companyId"] = this.companyId;
        data["companyName"] = this.companyName;
        data["storeSetting"] = this.storeSetting;
        data["connectionStatus"] = this.connectionStatus;
        data["pointBalanceAccessKey"] = this.pointBalanceAccessKey;
        data["greetingMessage"] = this.greetingMessage;
        data["logoLink"] = this.logoLink;
        return data;
    }
}

export interface IStoreDTO {
    id?: number;
    encryptedId?: string | undefined;
    storename?: string | undefined;
    startingHourOfTheDay?: number;
    beginDayOfWeek?: DayOfWeek;
    dataMinerAccessKey?: string | undefined;
    companyId?: number | undefined;
    companyName?: string | undefined;
    storeSetting?: string | undefined;
    connectionStatus?: string | undefined;
    pointBalanceAccessKey?: string | undefined;
    greetingMessage?: string | undefined;
    logoLink?: string | undefined;
}

export enum DayOfWeek {
    Sunday = "Sunday",
    Monday = "Monday",
    Tuesday = "Tuesday",
    Wednesday = "Wednesday",
    Thursday = "Thursday",
    Friday = "Friday",
    Saturday = "Saturday",
}

export class EventResponse implements IEventResponse {
    contentModel!: EventItemModel;

    constructor(data?: IEventResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.contentModel = new EventItemModel();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contentModel = _data["contentModel"] ? EventItemModel.fromJS(_data["contentModel"]) : new EventItemModel();
        }
    }

    static fromJS(data: any): EventResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EventResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentModel"] = this.contentModel ? this.contentModel.toJSON() : <any>undefined;
        return data;
    }
}

export interface IEventResponse {
    contentModel: EventItemModel;
}

export class EventItemModel implements IEventItemModel {
    eventId!: number;
    eventDesc!: string;
    eventDate!: Date;
    approved!: EventApproved;
    approvrdById!: string;
    approvedByName!: string;
    jrCashierId!: number;
    jrCashierName!: string;
    neededManagerLevel!: number;
    jrtrx!: string;
    reg!: string;

    constructor(data?: IEventItemModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eventId = _data["eventId"];
            this.eventDesc = _data["eventDesc"];
            this.eventDate = _data["eventDate"] ? new Date(_data["eventDate"].toString()) : <any>undefined;
            this.approved = _data["approved"];
            this.approvrdById = _data["approvrdById"];
            this.approvedByName = _data["approvedByName"];
            this.jrCashierId = _data["jrCashierId"];
            this.jrCashierName = _data["jrCashierName"];
            this.neededManagerLevel = _data["neededManagerLevel"];
            this.jrtrx = _data["jrtrx"];
            this.reg = _data["reg"];
        }
    }

    static fromJS(data: any): EventItemModel {
        data = typeof data === 'object' ? data : {};
        let result = new EventItemModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventId"] = this.eventId;
        data["eventDesc"] = this.eventDesc;
        data["eventDate"] = this.eventDate ? this.eventDate.toISOString() : <any>undefined;
        data["approved"] = this.approved;
        data["approvrdById"] = this.approvrdById;
        data["approvedByName"] = this.approvedByName;
        data["jrCashierId"] = this.jrCashierId;
        data["jrCashierName"] = this.jrCashierName;
        data["neededManagerLevel"] = this.neededManagerLevel;
        data["jrtrx"] = this.jrtrx;
        data["reg"] = this.reg;
        return data;
    }
}

export interface IEventItemModel {
    eventId: number;
    eventDesc: string;
    eventDate: Date;
    approved: EventApproved;
    approvrdById: string;
    approvedByName: string;
    jrCashierId: number;
    jrCashierName: string;
    neededManagerLevel: number;
    jrtrx: string;
    reg: string;
}

export enum EventApproved {
    Awaiting_Authorization = "Awaiting_Authorization",
    Authorized = "Authorized",
    Deny_Authorization = "Deny_Authorization",
    Cancel_Authorization = "Cancel_Authorization",
}

export class UsersDto implements IUsersDto {
    id?: number;
    userName?: string | undefined;
    companyName?: string | undefined;
    stores?: string | undefined;

    constructor(data?: IUsersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.companyName = _data["companyName"];
            this.stores = _data["stores"];
        }
    }

    static fromJS(data: any): UsersDto {
        data = typeof data === 'object' ? data : {};
        let result = new UsersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["companyName"] = this.companyName;
        data["stores"] = this.stores;
        return data;
    }
}

export interface IUsersDto {
    id?: number;
    userName?: string | undefined;
    companyName?: string | undefined;
    stores?: string | undefined;
}

export class UpdateUser implements IUpdateUser {
    companyName?: string | undefined;
    stores?: string | undefined;

    constructor(data?: IUpdateUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyName = _data["companyName"];
            this.stores = _data["stores"];
        }
    }

    static fromJS(data: any): UpdateUser {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyName"] = this.companyName;
        data["stores"] = this.stores;
        return data;
    }
}

export interface IUpdateUser {
    companyName?: string | undefined;
    stores?: string | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}